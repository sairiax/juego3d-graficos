<!DOCTYPE html>
<html>
<head>
    <title>Planet Invasion Survival con Three.js - Juego de Supervivencia</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000; 
            overflow: hidden;
            color: #fff;
        }
        
        #container { 
            width: 100%; 
            height: 100vh; 
            position: relative; 
        }
        
        /* UI Panel */
        #ui {
            position: absolute;
            top: 15px;
            left: 15px;
            color: white;
            z-index: 100;
            background: rgba(0, 10, 20, 0.85);
            padding: 20px;
            border-radius: 12px;
            border: 2px solid rgba(0, 255, 100, 0.6);
            box-shadow: 0 0 25px rgba(0, 255, 100, 0.4), inset 0 0 15px rgba(0, 255, 100, 0.1);
            font-size: 14px;
            min-width: 200px;
            backdrop-filter: blur(10px);
        }
        
        #ui > div {
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        #healthBar {
            width: 180px;
            height: 24px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 12px;
            overflow: hidden;
            margin-top: 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.5);
        }
        
        #healthFill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #88ff00, #ffff00, #ff8800, #ff0000);
            width: 100%;
            transition: width 0.3s ease, filter 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.6);
        }
        
        #time, #hits, #score, #planetRadius {
            font-weight: bold;
            text-shadow: 0 0 8px currentColor;
            color: #00ff88;
        }
        
        #invulnIndicator, #lavaWarning {
            font-size: 13px;
            font-weight: bold;
            padding: 5px 10px;
            border-radius: 6px;
            margin-top: 8px;
            animation: pulse 0.8s infinite;
        }
        
        #invulnIndicator {
            color: #00ffff;
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid #00ffff;
            display: none;
        }
        
        #lavaWarning {
            color: #ff4500;
            background: rgba(255, 69, 0, 0.2);
            border: 1px solid #ff4500;
            display: none;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.05); }
        }
        
        /* Game Over / Win Screens */
        #gameOver, #winScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            z-index: 200;
            background: rgba(0, 0, 0, 0.95);
            padding: 40px 50px;
            border-radius: 20px;
            border: 3px solid;
            box-shadow: 0 0 40px;
            display: none;
            font-size: 18px;
            backdrop-filter: blur(10px);
            animation: slideIn 0.5s ease-out;
        }
        
        @keyframes slideIn {
            from { transform: translate(-50%, -60%); opacity: 0; }
            to { transform: translate(-50%, -50%); opacity: 1; }
        }
        
        #gameOver {
            border-color: #ff0000;
            box-shadow: 0 0 40px rgba(255, 0, 0, 0.6);
        }
        
        #winScreen {
            border-color: #00ff00;
            box-shadow: 0 0 40px rgba(0, 255, 0, 0.6);
        }
        
        #winScreen h2 {
            color: #00ff00;
            text-shadow: 0 0 15px #00ff00;
            font-size: 48px;
            margin-bottom: 20px;
        }
        
        #gameOver h2 {
            color: #ff0000;
            text-shadow: 0 0 15px #ff0000;
            font-size: 48px;
            margin-bottom: 20px;
        }
        
        #restartBtn {
            background: linear-gradient(135deg, #00ff00, #00cc00);
            color: #000;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 255, 0, 0.4);
        }
        
        #restartBtn:hover {
            background: linear-gradient(135deg, #00cc00, #009900);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 255, 0, 0.6);
        }
        
        #restartBtn:active {
            transform: translateY(0);
        }
        
        /* Instructions Panel */
        #instructions {
            position: absolute;
            bottom: 15px;
            left: 15px;
            color: white;
            z-index: 100;
            background: rgba(0, 10, 20, 0.85);
            padding: 18px;
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 0, 0.6);
            box-shadow: 0 0 25px rgba(255, 255, 0, 0.4);
            font-size: 13px;
            max-width: 320px;
            backdrop-filter: blur(10px);
        }
        
        #instructions strong {
            color: #ffff00;
            font-size: 15px;
        }
        
        /* Tips Panel */
        #tips {
            position: absolute;
            bottom: 15px;
            right: 15px;
            color: white;
            z-index: 100;
            background: rgba(0, 10, 20, 0.85);
            padding: 15px;
            border-radius: 12px;
            border: 2px solid rgba(255, 0, 255, 0.6);
            box-shadow: 0 0 25px rgba(255, 0, 255, 0.4);
            font-size: 12px;
            max-width: 220px;
            backdrop-filter: blur(10px);
        }
        
        #tips strong {
            color: #ff00ff;
            font-size: 14px;
        }
        
        /* Minimap */
        #minimap {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 160px;
            height: 160px;
            background: rgba(0, 10, 20, 0.85);
            border-radius: 50%;
            border: 3px solid rgba(0, 255, 255, 0.6);
            overflow: hidden;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5), inset 0 0 20px rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
        }
        
        #minimap canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        /* Loading Screen */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            z-index: 200;
            background: rgba(0, 0, 0, 0.95);
            padding: 40px 60px;
            border-radius: 20px;
            border: 2px solid #00ffff;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.5);
            backdrop-filter: blur(10px);
        }
        
        #loading h2 {
            color: #00ffff;
            text-shadow: 0 0 15px #00ffff;
            font-size: 32px;
            margin-bottom: 15px;
        }
        
        .spinner {
            border: 4px solid rgba(0, 255, 255, 0.3);
            border-top: 4px solid #00ffff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Score popup animation */
        .score-popup {
            position: absolute;
            color: #ffff00;
            font-weight: bold;
            font-size: 20px;
            text-shadow: 0 0 10px #ffff00;
            pointer-events: none;
            animation: scoreFloat 1s ease-out forwards;
        }
        
        @keyframes scoreFloat {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-50px) scale(1.5); }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="ui">
            <div><span>Tiempo:</span> <span id="time">0</span>s</div>
            <div><span>SCORE:</span> <span id="score">0</span></div>
            <div><span>Golpes:</span> <span id="hits">0</span>/3</div>
            <div id="healthBar">
                <div id="healthFill"></div>
            </div>
            <div><span>Radio Planeta:</span> <span id="planetRadius">40</span></div>
            <div id="invulnIndicator">INVULNERABLE!</div>
            <div id="lavaWarning">EN LAVA! Daño continuo...</div>
        </div>
        
        <div id="instructions">
            <strong>Controles:</strong><br>
            W: Mover adelante<br>
            A/D: Girar<br>
            S: Vuelta 180 grados<br><br>
            <strong>Objetivo:</strong><br>
            Sobrevive mientras el planeta se encoge cada 10s!<br>
            Colecciona power-ups para curarte.<br>
            Evita meteoritos, lava y enemigos.<br>
            <small>Gana sobreviviendo hasta radio 5!</small>
        </div>
        
        <div id="minimap"></div>
        
        <div id="gameOver">
            <h2>GAME OVER!</h2>
            <p>Tiempo sobrevivido: <span id="finalTime">0</span>s</p>
            <p>SCORE final: <span id="finalScore">0</span></p>
            <p>Mejor SCORE: <span id="bestScore">0</span></p>
            <button id="restartBtn" onclick="location.reload()">Reiniciar</button>
        </div>
        
        <div id="winScreen">
            <h2>VICTORIA!</h2>
            <p>Tiempo: <span id="winTime">0</span>s</p>
            <p>SCORE: <span id="winScore">0</span></p>
            <button id="restartBtn" onclick="location.reload()">Jugar de nuevo</button>
        </div>
        
        <div id="loading">
            <h2>Cargando planeta...</h2>
            <div class="spinner"></div>
            <p>Por favor espera.</p>
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="js/FBXLoader.js"></script>
    <script src="js/inflate.min.js"></script>

    <script>
        // Glitch shaders - more obvious for enemies
        const glitchVertexShader = `
            varying vec2 vUv;
            varying vec3 vPosition;
            uniform float time;
            float hash(vec3 p3) {
                p3  = fract(p3 * 0.3183099 + 0.1);
                return fract(sin(dot(p3, vec3(127.1, 311.7, 74.7))) * 43758.5453);
            }
            void main() {
                vUv = uv;
                vPosition = position;
                vec3 pos = position;
                vec3 p = pos + time * 1.0; // Faster change
                float h = hash(p);
                pos.xyz += (h * 2.0 - 1.0) * 0.3; // Stronger displacement
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `;

        const glitchFragmentShader = `
            varying vec2 vUv;
            varying vec3 vPosition;
            uniform float time;
            uniform vec3 baseColor;
            float hash(vec3 p3) {
                p3  = fract(p3 * 0.3183099 + 0.1);
                return fract(sin(dot(p3, vec3(127.1, 311.7, 74.7))) * 43758.5453);
            }
            void main() {
                vec3 col = baseColor;
                vec3 p = vPosition + time * 0.6; // Faster
                float h = hash(p * 0.1);
                col.rgb += (h - 0.5) * 1.0; // Stronger color shift
                float lineh = fract(sin(dot(vPosition.xy, vec2(12.9898, 78.233))) * 43758.5453);
                if (lineh > 0.95) {
                    col += vec3(0.0, 1.0, 0.0) * 0.8; // Stronger scanlines
                }
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        // Different glitch for lava - more fiery
        const lavaVertexShader = `
            varying vec2 vUv;
            varying vec3 vPosition;
            uniform float time;
            void main() {
                vUv = uv;
                vPosition = position;
                vec3 pos = position;
                pos.y += sin(time * 2.0 + pos.x * 5.0) * 0.1; // Wavy displacement
                pos.x += cos(time * 3.0 + pos.z * 3.0) * 0.05;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `;

        const lavaFragmentShader = `
            varying vec2 vUv;
            varying vec3 vPosition;
            uniform float time;
            uniform vec3 baseColor;
            void main() {
                vec3 col = baseColor;
                col.r += sin(time * 4.0 + vUv.x * 10.0) * 0.3; // Red flicker
                col.g += cos(time * 3.0 + vUv.y * 8.0) * 0.2; // Orange wave
                col.b += sin(time * 5.0) * 0.1; // Slight blue for heat
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        // --- REFERENCIAS GLOBALES ---
        var renderer, scene, camera, planeta, previousRadial, cube;
        let sunLight;
        var clock = new THREE.Clock();

        // --- GESTIÓN DE ANIMACIÓN ---
        var mixer;
        const actions = {}; 
        let activeAction; 

        // --- ESTADO DEL JUEGO ---
        let gameRunning = true;
        let gameTime = 0;
        let score = 0;
        let hits = 0;
        const MAX_HITS = 3;
        let obstacles = [];
        let staticObstacles = []; // Nuevo: para rocas y árboles
        let lavaSpots = []; // Zonas de lava como peligro adicional
        let explosions = [];
        let powerUps = [];
        let enemies = []; // Nuevo: enemigos que persiguen al jugador
        let bestScore = localStorage.getItem('bestScore') || 0;

        // Auto shrink
        let lastAutoShrinkTime = 0;
        const AUTO_SHRINK_INTERVAL = 10;

        // Invulnerabilidad
        let invulnerable = false;
        let invulnTimer = 0;
        const INVULN_DURATION = 3; // Reducido a 3s para más dificultad

        // Daño de lava
        let inLava = false;
        let lavaDamageTimer = 0;
        const LAVA_DAMAGE_INTERVAL = 0.3; // Reducido a 0.3s para daño más frecuente

        // Seguimiento de carga de modelos
        const modelsToLoad = 8; // player model + 2 anims + 3 enemies + tree + meteor/lava
        let modelsLoaded = 0;
        let isInitialized = false;

        // Meteor/Lava model template
        let meteorLavaTemplate;

        // Player initial position
        const playerInitialPos = new THREE.Vector3(0, 40 + 0.5, 0);

        // --- CONSTANTES DE CONFIGURACIÓN ---
        const originalPlanetRadius = 40;
        let currentPlanetRadius = originalPlanetRadius;
        const CHARACTER_HEIGHT = 0.5;
        const CHARACTER_SCALE = 0.02;
        const FORWARD_SPEED = 8.0; // Reducido de 10 a 8 para más dificultad
        const TURN_SPEED = 2.0;
        const CAMERA_DISTANCE = 1000;
        const CAMERA_HEIGHT = 700;
        const STATIC_COLLISION_DISTANCE = 0.8;
        const TREE_COLLISION_DISTANCE = 5;
        const SHRINK_AMOUNT = 5.0;
        const WIN_RADIUS = 5.0;
        const BLAST_DAMAGE_RADIUS = 3.0;

        // --- CONFIGURACIÓN DE OBSTÁCULOS MEJORADA ---
        let METEOR_SPAWN_RATE = 0.015; // Aumentado inicial para más meteoritos
        const METEOR_SPEED = 35; // Aumentado de 30 a 35
        const METEOR_RADIUS = 1;
        const EXPLOSION_RADIUS = 5;
        const EXPLOSION_DURATION = 1;
        const COLLISION_DISTANCE = 2.0; // Reducido de 2.5 para colisiones más fáciles (más difícil)
        let POWERUP_SPAWN_RATE = 0.0005; // Reducido para menos powerups
        const POWERUP_RADIUS = 0.5;
        const SCORE_PER_SECOND = 10;
        const SCORE_PER_POWERUP = 100;
        const SCORE_PER_ENEMY = 50; // Puntos por destruir enemigo
        const DIFFICULTY_INCREASE_INTERVAL = 8; // Reducido de 10 a 8 para aumento más rápido
        let lastDifficultyIncrease = 0;
        let lastSecond = 0;

        // Configuración de enemigos variados (velocidad aumentada para dificultad)
        let ENEMY_SPAWN_RATE = 0.008; // Ligeramente reducido para no añadir más, pero velocidad interna aumentada
        const ENEMY_SPEED = 2.0; // Aumentado de 1.5 a 2.0
        const ENEMY_RADIUS = 0.8;
        const ENEMY_TYPES = [
            { name: 'chaser', model: 'models/e1.glb', scale: 1.0, color: 0xff00ff, speed: 2.0, behavior: 'chase' },
            { name: 'brute', model: 'models/e2.glb', scale: 0.8, color: 0xff00ff, speed: 1.2, behavior: 'chase' },
            { name: 'jumper', model: 'models/e3.glb', scale: 1.2, color: 0xff00ff, speed: 1.6, behavior: 'jump' }
        ];
        
        // Cache de modelos de enemigos
        const enemyModels = {};

        // Minimap
        let minimapRenderer, minimapCamera;
        let minimapAngle = 0;

        // Textura de piedra (cargada globalmente)
        let stoneTexture;

        // --- ESTADO DEL TECLADO ---
        var keysPressed = {};
        document.addEventListener('keydown', (event) => {
            keysPressed[event.key.toLowerCase()] = true;
        }, false);
        document.addEventListener('keyup', (event) => keysPressed[event.key.toLowerCase()] = false, false);

        let personaje;

        init();
        loadPlaneta(originalPlanetRadius, 'images/planet.png');
        loadPersonaje('models/c.fbx', CHARACTER_SCALE);
        preloadEnemyModels();
        loadMeteorLavaModel();
        render();

        function modelLoaded() {
            modelsLoaded++;
            if (modelsLoaded === modelsToLoad) {
                isInitialized = true;
                document.getElementById('loading').style.display = 'none';
                console.log('All models loaded');
            }
        }

        function init() {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(new THREE.Color(0x000011)); // Fondo más estrellado
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2; // Reducido para menos sobreexposición
            document.getElementById('container').appendChild(renderer.domElement);

            // Minimap setup mejorado
            const minimapDiv = document.getElementById('minimap');
            minimapRenderer = new THREE.WebGLRenderer({ antialias: false });
            minimapRenderer.setSize(150, 150);
            minimapRenderer.setClearColor(0x000022);
            minimapRenderer.shadowMap.enabled = false;
            minimapDiv.appendChild(minimapRenderer.domElement);

            minimapCamera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            minimapCamera.position.set(0, 0, originalPlanetRadius * 3);
            minimapCamera.lookAt(0, 0, 0);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            
            camera.position.set(0, originalPlanetRadius + CAMERA_HEIGHT + 10, 20);
            camera.lookAt(0, originalPlanetRadius, 0);
            
            // Estrellas mejoradas con más brillo
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 30000; // Más estrellas
            const positions = new Float32Array(starCount * 3);
            const sizes = new Float32Array(starCount);
            const colors = new Float32Array(starCount * 3);
            for (let i = 0; i < starCount; i++) {
                const i3 = i * 3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 800 + Math.random() * 1200;
                positions[i3] = r * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = r * Math.cos(phi);
                
                sizes[i] = Math.random() * 4 + 1; // Tamaños variados
                
                const color = new THREE.Color();
                color.setHSL(Math.random() * 0.1 + 0.55, 0.7, Math.random() * 0.3 + 0.7); // Colores más vibrantes
                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;
            }
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            const starMaterial = new THREE.PointsMaterial({ 
                size: 3, 
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                sizeAttenuation: true 
            });
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
            
            // Iluminación ajustada para menos blanco, más cálida y equilibrada
            scene.add(new THREE.AmbientLight(0x404040, 0.6)); // Aumentado ligeramente para más luz ambiental sin lavar
            
            const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x444444, 1.0); // Cielo azul, suelo gris, intensidad aumentada un poco
            hemiLight.position.set(0, 200, 0);
            scene.add(hemiLight);
            
            sunLight = new THREE.DirectionalLight(0xffddaa, 2.0); // Color cálido, intensidad media-alta
            sunLight.position.set(200, 150, 100);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 4096;
            sunLight.shadow.mapSize.height = 4096;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 1000;
            sunLight.shadow.camera.left = -originalPlanetRadius * 3;
            sunLight.shadow.camera.right = originalPlanetRadius * 3;
            sunLight.shadow.camera.top = originalPlanetRadius * 3;
            sunLight.shadow.camera.bottom = -originalPlanetRadius * 3;
            sunLight.shadow.bias = -0.0001;
            sunLight.shadow.normalBias = 0.0005;
            scene.add(sunLight);

            // Luz de relleno suave para evitar sombras duras, sin blanco puro
            const fillLight = new THREE.DirectionalLight(0xddddff, 0.8); // Tono azulado suave
            fillLight.position.set(-200, -150, -100);
            fillLight.castShadow = false;
            scene.add(fillLight);

            // Sol visible con glow ajustado
            const sunGeometry = new THREE.SphereGeometry(8, 64, 64);
            const sunMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffddaa,
                transparent: true,
                opacity: 0.95
            });
            const sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sun.position.copy(sunLight.position);
            scene.add(sun);

            const glowGeometry = new THREE.SphereGeometry(25, 64, 64);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffaa00, 
                transparent: true, 
                opacity: 0.4,
                side: THREE.BackSide 
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.copy(sunLight.position);
            scene.add(glow);

            const haloGeometry = new THREE.TorusGeometry(30, 2, 16, 100);
            const haloMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.3 
            });
            const halo = new THREE.Mesh(haloGeometry, haloMaterial);
            halo.position.copy(sunLight.position);
            halo.rotation.x = Math.PI / 2;
            scene.add(halo);

            function animateHalo() {
                if (halo) halo.rotation.z += 0.005;
                requestAnimationFrame(animateHalo);
            }
            animateHalo();

            const sunPointLight = new THREE.PointLight(0xffddaa, 1.0, 300); // Color cálido, intensidad media
            sunPointLight.position.copy(sunLight.position);
            scene.add(sunPointLight);

            // Luz ambiental cerca del planeta, suave
            const planetPointLight = new THREE.PointLight(0xaaaaaa, 0.5, 100);
            planetPointLight.position.set(0, 0, 0);
            scene.add(planetPointLight);

            // More particles for freezer planet - snow-like
            const snowGeometry = new THREE.BufferGeometry();
            const snowCount = 5000; // Increased
            const snowPositions = new Float32Array(snowCount * 3);
            const snowVelocities = new Float32Array(snowCount * 3); // Add velocities for falling
            const snowColors = new Float32Array(snowCount * 3);
            for (let i = 0; i < snowCount; i++) {
                const i3 = i * 3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = originalPlanetRadius * (1 + Math.random() * 0.2); // Slightly farther
                snowPositions[i3] = r * Math.sin(phi) * Math.cos(theta);
                snowPositions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                snowPositions[i3 + 2] = r * Math.cos(phi);
                
                // Velocity towards center for falling snow
                const dir = new THREE.Vector3(snowPositions[i3], snowPositions[i3+1], snowPositions[i3+2]).normalize();
                const speed = 0.5 + Math.random() * 1.0;
                snowVelocities[i3] = -dir.x * speed;
                snowVelocities[i3 + 1] = -dir.y * speed;
                snowVelocities[i3 + 2] = -dir.z * speed;
                
                // White with blue tint
                snowColors[i3] = 0.9 + Math.random() * 0.1;
                snowColors[i3 + 1] = 0.9 + Math.random() * 0.1;
                snowColors[i3 + 2] = 0.8 + Math.random() * 0.2;
            }
            snowGeometry.setAttribute('position', new THREE.BufferAttribute(snowPositions, 3));
            snowGeometry.setAttribute('velocity', new THREE.BufferAttribute(snowVelocities, 3));
            snowGeometry.setAttribute('color', new THREE.BufferAttribute(snowColors, 3));
            const snowMaterial = new THREE.PointsMaterial({
                size: 0.3,
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                sizeAttenuation: true
            });
            const snow = new THREE.Points(snowGeometry, snowMaterial);
            scene.add(snow);
            window.snow = snow; // Exponer para acceso global

            // Cargar textura de piedra
            const textureLoader = new THREE.TextureLoader();
            stoneTexture = textureLoader.load('https://threejs.org/examples/textures/brick_diffuse.jpg'); // Textura de piedra/brick como ejemplo; reemplaza con una específica de piedra si tienes

            window.addEventListener('resize', updateAspectRatio);

            setInterval(updateUI, 100);
        }

        function loadMeteorLavaModel() {
            const loader = new THREE.GLTFLoader();
            loader.load('models/a.glb', function(gltf) {
                meteorLavaTemplate = gltf.scene.clone();
                meteorLavaTemplate.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                console.log('Meteor/Lava model loaded');
                modelLoaded();
            }, undefined, function(error) {
                console.error('Error loading meteor/lava model:', error);
                // Fallback: create a simple geometry for both
                const fallbackGeo = new THREE.DodecahedronGeometry(1, 1);
                const fallbackMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                const fallbackModel = new THREE.Mesh(fallbackGeo, fallbackMat);
                fallbackModel.userData.fallback = true;
                meteorLavaTemplate = fallbackModel;
                console.log('Fallback created for meteor/lava');
                modelLoaded();
            });
        }

        function loadPlaneta(radio, texturaURL) {
            const geometria = new THREE.SphereGeometry(radio, 128, 128);
            const textura = new THREE.TextureLoader().load(texturaURL);
            const material = new THREE.MeshStandardMaterial({ 
                map: textura,
                normalMap: textura, // Añadir normal map para relieve (usando la misma textura como approx)
                normalScale: new THREE.Vector2(0.5, 0.5),
                metalness: 0.05, // Menos metálico
                roughness: 0.9 // Más rugoso para realismo
            });
            planeta = new THREE.Mesh(geometria, material);
            planeta.receiveShadow = true;
            planeta.castShadow = true;
            planeta.userData.originalRadius = radio;
            scene.add(planeta);

            // Bump map simulado para textura al encoger
            planeta.userData.originalScale = 1.0;

            // Load tree model instead of procedural
            const treeLoader = new THREE.GLTFLoader();
            treeLoader.load('models/tree.glb', function(gltf) {
                const treeTemplate = gltf.scene.clone(); // Clone to avoid sharing
                treeTemplate.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                treeTemplate.scale.set(3, 3, 3); // Escala razonable para GLTF (ajusta según el tamaño de tu modelo; prueba 0.1-2.0)

                const numTrees = 200; // Reducido para mejor rendimiento con escalas grandes
                let placedTrees = 0;
                while (placedTrees < numTrees) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const pos = new THREE.Vector3(
                        radio * Math.sin(phi) * Math.cos(theta),
                        radio * Math.sin(phi) * Math.sin(theta),
                        radio * Math.cos(phi)
                    );
                    const distToPlayer = pos.distanceTo(playerInitialPos);
                    if (distToPlayer < 10) continue; // Skip if too close to player

                    const tree = treeTemplate.clone();
                    tree.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    tree.position.copy(pos);
                    const radial = pos.clone().normalize();
                    const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), radial);
                    tree.quaternion.copy(quat);
                    tree.castShadow = true;
                    tree.receiveShadow = true;
                    // Offset para evitar que se entierren
                    const treeOffset = CHARACTER_HEIGHT + 4;
                    tree.position.add(radial.clone().multiplyScalar(treeOffset));
                    tree.userData = {
                        isTree: true,
                        radial: radial.clone(),
                        offset: treeOffset
                    };
                    scene.add(tree);
                    staticObstacles.push(tree);
                    placedTrees++;
                }
                console.log('Trees loaded from GLTF');
                modelLoaded();
            }, undefined, function(error) {
                console.error('Error loading tree model:', error);
                createProceduralTrees(radio); // Fallback a procedural si GLTF falla
            });

            // No initial lava - only from meteors
        }

        function createProceduralTrees(radio) {
            // Fallback procedural trees
            const numTrees = 100;
            let placedTrees = 0;
            while (placedTrees < numTrees) {
                const treeHeight = 3 + Math.random() * 2;
                const trunkGeo = new THREE.CylinderGeometry(0.2, 0.3, 1.5, 8);
                const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                const foliageGeo = new THREE.SphereGeometry(1.5, 8, 8);
                const foliageMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });
                const foliage = new THREE.Mesh(foliageGeo, foliageMat);
                foliage.position.y = 1.5;
                const tree = new THREE.Group();
                tree.add(trunk);
                tree.add(foliage);
                tree.scale.set(1, treeHeight / 3, 1);

                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const pos = new THREE.Vector3(
                    radio * Math.sin(phi) * Math.cos(theta),
                    radio * Math.sin(phi) * Math.sin(theta),
                    radio * Math.cos(phi)
                );
                const distToPlayer = pos.distanceTo(playerInitialPos);
                if (distToPlayer < 10) continue; // Skip if too close

                tree.position.copy(pos);
                const radial = pos.clone().normalize();
                const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), radial);
                tree.quaternion.copy(quat);
                const treeOffset = CHARACTER_HEIGHT;
                tree.position.add(radial.clone().multiplyScalar(treeOffset));
                tree.userData = {
                    isTree: true,
                    radial: radial.clone(),
                    offset: treeOffset
                };
                tree.castShadow = true;
                tree.receiveShadow = true;
                scene.add(tree);
                staticObstacles.push(tree);
                placedTrees++;
            }
            modelLoaded();
        }

        function spawnLava(position) {
            const lavaRadius = 1.0 + Math.random() * 0.3; // Reducido tamaño para que sea un poco más pequeña
            // Improved shape: procedural blob-like icosahedron for better lava form
            const lavaGeometry = new THREE.IcosahedronGeometry(lavaRadius, 3); // Higher detail for irregular shape
            const lavaMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0.0 },
                    baseColor: { value: new THREE.Color(0xff4500) } // Brighter orange-red for lava
                },
                vertexShader: lavaVertexShader,
                fragmentShader: lavaFragmentShader,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide
            });
            const lava = new THREE.Mesh(lavaGeometry, lavaMaterial);
            lava.castShadow = true;
            lava.receiveShadow = true;

            const radial = position.clone().normalize();
            lava.position.copy(position);
            const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), radial);
            lava.quaternion.copy(quat);

            scene.add(lava);
            lavaSpots.push(lava);
            lava.userData.originalPosition = position.clone().multiplyScalar(originalPlanetRadius / currentPlanetRadius);
            lava.userData.pulseTime = Math.random() * Math.PI * 2;

            // Partículas de humo más densas
            for (let s = 0; s < 3; s++) {
                const smokeGeo = new THREE.SphereGeometry(0.3, 4, 4);
                const smokeMat = new THREE.MeshBasicMaterial({
                    color: 0x222222,
                    transparent: true,
                    opacity: 0.4
                });
                const smoke = new THREE.Mesh(smokeGeo, smokeMat);
                smoke.position.copy(lava.position);
                smoke.position.add(new THREE.Vector3(
                    (Math.random() - 0.5) * lavaRadius,
                    lavaRadius + 0.5 + Math.random(),
                    (Math.random() - 0.5) * lavaRadius
                ));
                scene.add(smoke);
                lava.userData.smokes = lava.userData.smokes || [];
                lava.userData.smokes.push(smoke);
            }
        }

        // --- SPAWN DE ENEMIGOS VARIADOS ---
        function preloadEnemyModels() {
            const loader = new THREE.GLTFLoader();
            ENEMY_TYPES.forEach(type => {
                loader.load(type.model, function(gltf) {
                    const model = gltf.scene.clone();
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            // Aplicar color tintado y textura metálica reflectante
                            if (child.material) {
                                child.material = child.material.clone();
                                child.material.color.set(type.color);
                                child.material.emissive = new THREE.Color(type.color);
                                child.material.emissiveIntensity = 0.3;
                                child.material.metalness = 1.0; // Máximo metálico
                                child.material.roughness = 0.1; // Bajo roughness para reflectividad
                                child.material.transparent = true;
                                child.material.opacity = 0.7;
                            }
                        }
                    });
                    enemyModels[type.name] = model;
                    console.log(`Modelo de enemigo ${type.name} cargado`);
                    modelLoaded();
                }, undefined, function(error) {
                    console.error(`Error cargando modelo ${type.model}:`, error);
                    // Fallback: Crear geometría procedural simple con textura metálica
                    const fallbackGeometry = type.name === 'chaser' ? 
                        new THREE.SphereGeometry(0.5, 8, 8) :  // Esfera para chaser
                        (type.name === 'brute' ? 
                            new THREE.CylinderGeometry(0.6, 0.8, 1.2, 8) :  // Cilindro ancho para brute
                            new THREE.ConeGeometry(0.4, 1.5, 8)  // Cono para jumper
                        );
                    const fallbackMaterial = new THREE.ShaderMaterial({ 
                        uniforms: {
                            time: { value: 0.0 },
                            baseColor: { value: new THREE.Color(type.color) }
                        },
                        vertexShader: glitchVertexShader,
                        fragmentShader: glitchFragmentShader,
                        transparent: true,
                        opacity: 0.7
                    });
                    const fallbackModel = new THREE.Mesh(fallbackGeometry, fallbackMaterial);
                    fallbackModel.userData = { fallback: true };  // Marcar como fallback
                    enemyModels[type.name] = fallbackModel;
                    console.log(`Fallback procedural creado para enemigo ${type.name}`);
                    modelLoaded();
                });
            });
        }

        function spawnEnemy() {
            if (!gameRunning || !isInitialized || Math.random() > ENEMY_SPAWN_RATE) return;

            if (lavaSpots.length === 0) return; // No lava, no spawn

            const type = ENEMY_TYPES[Math.floor(Math.random() * ENEMY_TYPES.length)];
            const modelTemplate = enemyModels[type.name];
            if (!modelTemplate) return;

            // Spawn from random lava
            const randomLava = lavaSpots[Math.floor(Math.random() * lavaSpots.length)];
            const lavaPos = randomLava.position.clone();

            // TEST: Reemplaza con geometría simple para visibilidad (cambia true a false para usar modelo real)
            let enemy;
            if (true) {  // Cambia a false para usar modelo real
                // Geometría fallback: esfera roja brillante para chaser, cilindro marrón para brute, cono magenta para jumper
                const geo = new THREE.SphereGeometry(0.5, 8, 8); // Unified to sphere for easier shape changing
                const enemyMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0.0 },
                        baseColor: { value: new THREE.Color(type.color) }
                    },
                    vertexShader: glitchVertexShader,
                    fragmentShader: glitchFragmentShader,
                    transparent: true,
                    opacity: 0.7
                });
                enemy = new THREE.Mesh(geo, enemyMaterial);
                enemy.userData.fallback = true;  // Marca para animación extra
                console.log(`Usando fallback para ${type.name}`);
            } else {
                enemy = modelTemplate.clone();
            }

            enemy.scale.set(type.scale, type.scale, type.scale);

            // Position slightly above lava
            const radial = lavaPos.clone().normalize();
            const height = CHARACTER_HEIGHT;
            const spawnRadius = currentPlanetRadius * 1.0 + height;
            const pos = radial.clone().multiplyScalar(spawnRadius);
            pos.add(new THREE.Vector3((Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2)); // Small offset

            enemy.position.copy(pos);
            const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), radial);
            enemy.quaternion.copy(quat);
            enemy.userData = { 
                radial: radial.clone(), 
                speed: type.speed * 2.5,  // Aumentado multiplicador para más velocidad
                behavior: type.behavior,
                type: type.name,
                height: height, // Usar la altura baja
                isEnemy: true,
                rotationSpeed: Math.random() * 0.5 + 0.5,
                shapeTime: Math.random() * Math.PI * 2 // For shape changing
            };
            
            // Asegura visibilidad: glow y sombras
            enemy.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    if (child.material) {
                        child.material.emissiveIntensity = 0.8;  // Aumenta glow
                        child.material.metalness = 1.0;
                        child.material.roughness = 0.1;
                        child.material.transparent = true;
                        child.material.opacity = 0.7;
                    }
                }
            });

            scene.add(enemy);
            enemies.push(enemy);

            // Agregar trail naranja para visibilidad, más largo para entretenimiento
            const trailPoints = [enemy.position.clone()];
            for (let j = 1; j < 8; j++) { // Aumentado a 8 puntos
                const backPos = enemy.position.clone().sub(radial.clone().multiplyScalar(j * 1));
                trailPoints.push(backPos);
            }
            const trailGeometry = new THREE.BufferGeometry().setFromPoints(trailPoints);
            const trailMaterial = new THREE.LineBasicMaterial({ color: 0xff4500, transparent: true, opacity: 0.6 });
            const trail = new THREE.Line(trailGeometry, trailMaterial);
            scene.add(trail);
            enemy.userData.trail = trail;

            console.log(`Enemigo ${type.name} spawn from lava en posición:`, pos);
        }

        function loadPersonaje(url, scale = 1.0) {
            const loader = new THREE.FBXLoader();
            loader.load(url, function(fbx) {
                personaje = fbx;
                personaje.scale.set(scale, scale, scale);
                const initialPos = playerInitialPos.clone();
                personaje.position.copy(initialPos);
                
                const initialRadial = initialPos.clone().normalize();
                const quatUp = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), initialRadial);
                const initialYaw = 0;
                const quatYaw = new THREE.Quaternion().setFromAxisAngle(initialRadial, initialYaw);
                const quat = quatUp.clone();
                quat.premultiply(quatYaw);
                personaje.quaternion.copy(quat);
                
                previousRadial = initialRadial.clone();
                
                personaje.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        if (child.material) {
                            child.material.metalness = 0.3;
                            child.material.roughness = 0.4; // Más brillante
                        }
                    }
                });
                
                scene.add(personaje);

                // Cube con mejor material
                const radius = originalPlanetRadius + CHARACTER_HEIGHT;
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(personaje.quaternion);
                forward.projectOnPlane(initialRadial).normalize();
                const distance = 20;
                const cubePos = initialRadial.clone().add(forward.clone().multiplyScalar(distance)).normalize().multiplyScalar(radius);
                const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
                const cubeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x00ff00,
                    emissive: 0x00aa00,
                    emissiveIntensity: 0.2
                });
                mixer = new THREE.AnimationMixer(personaje);

                // Cargar animaciones
                loadAnimation('models/still.fbx', 'Idle');
                loadAnimation('models/run.fbx', 'Walk');

                console.log('✅ Personaje cargado correctamente.');
                modelLoaded(); // Incrementar por el modelo del personaje
            }, undefined, function(error) {
                console.error('❌ Error al cargar el modelo:', error);
                modelLoaded(); // Incrementar incluso en error
            });
        }

        function loadAnimation(file, name) {
            const animLoader = new THREE.FBXLoader();
            animLoader.load(file, function(animFbx) {
                const clip = animFbx.animations[0]; // Asumir primer clip
                if (clip) {
                    actions[name] = mixer.clipAction(clip);
                    if (name === 'Idle') {
                        actions[name].setLoop(THREE.LoopRepeat, Infinity);
                        setActiveAction(actions[name]);
                    } else if (name === 'Walk') {
                        actions[name].setLoop(THREE.LoopRepeat, Infinity);
                    }
                    console.log(`${name} animation loaded`);
                }
                modelLoaded(); // Incrementar por cada animación
            }, undefined, function(error) {
                console.error(`Error loading ${name} animation:`, error);
                modelLoaded(); // Incrementar incluso en error
            });
        }

        function setActiveAction(actionToActivate) {
            if (activeAction === actionToActivate) return;
            if (activeAction) activeAction.fadeOut(0.3);
            
            actionToActivate.reset().setEffectiveTimeScale(1).setEffectiveWeight(1).fadeIn(0.3).play();
            activeAction = actionToActivate;
        }

        function updateAspectRatio() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        }

        function updateUI() {
            if (!gameRunning) return;
            document.getElementById('time').textContent = Math.floor(gameTime);
            document.getElementById('score').textContent = Math.floor(score);
            document.getElementById('hits').textContent = hits;
            document.getElementById('healthFill').style.width = ((MAX_HITS - hits) / MAX_HITS * 100) + '%';
            document.getElementById('planetRadius').textContent = Math.floor(currentPlanetRadius);

            // Indicadores informativos
            const invulnEl = document.getElementById('invulnIndicator');
            const lavaEl = document.getElementById('lavaWarning');
            if (invulnerable) {
                invulnEl.style.display = 'block';
            } else {
                invulnEl.style.display = 'none';
            }
            if (inLava) {
                lavaEl.style.display = 'block';
            } else {
                lavaEl.style.display = 'none';
            }
        }

        function shrinkPlanet() {
            if (currentPlanetRadius <= WIN_RADIUS) return;
            const oldRadius = currentPlanetRadius;
            currentPlanetRadius = Math.max(WIN_RADIUS, currentPlanetRadius - SHRINK_AMOUNT);
            const scaleFactor = currentPlanetRadius / oldRadius;

            // Scale planet mesh (sin ajuste de repeat para que la textura se encoge con el planeta)
            if (planeta) {
                planeta.scale.multiplyScalar(scaleFactor);
            }

            // Update static obstacles positions
            for (let obj of staticObstacles) {
                if (obj.userData) {
                    let newPos;
                    if (obj.userData.isTree) {
                        // Para árboles: nueva posición = radial * (currentRadius + offset)
                        newPos = obj.userData.radial.clone().multiplyScalar(currentPlanetRadius + obj.userData.offset);
                    } else if (obj.userData.originalPosition) {
                        // Para rocas: escalar posición original
                        newPos = obj.userData.originalPosition.clone().multiplyScalar(currentPlanetRadius / originalPlanetRadius);
                    } else {
                        continue;
                    }
                    obj.position.copy(newPos);
                }
            }

            // Update lava spots positions y animar humo
            for (let lava of lavaSpots) {
                if (lava.userData && lava.userData.originalPosition) {
                    const newPos = lava.userData.originalPosition.clone().multiplyScalar(currentPlanetRadius / originalPlanetRadius);
                    lava.position.copy(newPos);
                    if (lava.userData.smokes) {
                        lava.userData.smokes.forEach(smoke => {
                            smoke.position.copy(newPos);
                            smoke.position.add(new THREE.Vector3(
                                (Math.random() - 0.5) * 1.0,
                                1.0 + 0.5 + Math.random(),
                                (Math.random() - 0.5) * 1.0
                            ));
                        });
                    }
                }
            }

            // Update powerups positions
            for (let pu of powerUps) {
                if (pu.userData && pu.userData.originalPosition) {
                    pu.position.copy(pu.userData.originalPosition.clone().multiplyScalar(currentPlanetRadius / originalPlanetRadius));
                }
            }

            // Update enemies positions (escalar hacia el centro, ajustando height)
            for (let enemy of enemies) {
                const scaledPos = enemy.position.clone().multiplyScalar(scaleFactor);
                const adjustedPos = scaledPos.normalize().multiplyScalar(currentPlanetRadius + enemy.userData.height);
                enemy.position.copy(adjustedPos);
                enemy.userData.radial = adjustedPos.clone().normalize();
            }

            // Actualizar bounds de la cámara de sombras para adaptarse al radio actual del planeta (esférico)
            if (sunLight && sunLight.shadow && sunLight.shadow.camera) {
                const shadowCamera = sunLight.shadow.camera;
                const shadowSize = currentPlanetRadius * 3;
                shadowCamera.left = -shadowSize;
                shadowCamera.right = shadowSize;
                shadowCamera.top = shadowSize;
                shadowCamera.bottom = -shadowSize;
                shadowCamera.updateProjectionMatrix();
            }

            if (currentPlanetRadius <= WIN_RADIUS) {
                winGame();
            }
        }

        function winGame() {
            gameRunning = false;
            document.getElementById('winTime').textContent = Math.floor(gameTime);
            document.getElementById('winScore').textContent = Math.floor(score);
            if (score > bestScore) {
                bestScore = score;
                localStorage.setItem('bestScore', bestScore);
            }
            document.getElementById('winScreen').style.display = 'block';
        }

        function endGame() {
            gameRunning = false;
            document.getElementById('finalTime').textContent = Math.floor(gameTime);
            document.getElementById('finalScore').textContent = Math.floor(score);
            if (score > bestScore) {
                bestScore = score;
                localStorage.setItem('bestScore', bestScore);
            }
            document.getElementById('bestScore').textContent = Math.floor(bestScore);
            document.getElementById('gameOver').style.display = 'block';
        }

        // --- SPAWN DE METEORITOS CON TRAIL MEJORADO ---
        function spawnMeteor() {
            if (!isInitialized || !gameRunning || Math.random() > METEOR_SPAWN_RATE || !meteorLavaTemplate) return;

            const spawnRadius = currentPlanetRadius * 5; // Aumentado para spawns más lejanos, pero speed compensa
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const x = spawnRadius * Math.sin(phi) * Math.cos(theta);
            const y = spawnRadius * Math.sin(phi) * Math.sin(theta);
            const z = spawnRadius * Math.cos(phi);

            const meteor = meteorLavaTemplate.clone();
            meteor.scale.set(METEOR_RADIUS, METEOR_RADIUS, METEOR_RADIUS);
            meteor.traverse((child) => {
                if (child.isMesh) {
                    child.material = new THREE.MeshStandardMaterial({ 
                        color: 0x8B4513,
                        emissive: 0xFF4500,
                        emissiveIntensity: 0.5 // Más glow
                    });
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            meteor.position.set(x, y, z);
            const direction = new THREE.Vector3().subVectors(new THREE.Vector3(0,0,0), meteor.position).normalize();
            meteor.userData = { direction: direction, speed: METEOR_SPEED, isMeteor: true };

            // Trail mejorado con múltiples segmentos, más largo para entretenimiento
            const trailPoints = [];
            for (let j = 0; j < 15; j++) { // Aumentado a 15
                trailPoints.push(meteor.position.clone().add(direction.clone().multiplyScalar(-j * 2)));
            }
            const trailGeometry = new THREE.BufferGeometry().setFromPoints(trailPoints);
            const trailMaterial = new THREE.LineBasicMaterial({ 
                color: 0xFF4500, 
                transparent: true, 
                opacity: 0.7,
                linewidth: 2
            });
            const trail = new THREE.Line(trailGeometry, trailMaterial);
            meteor.userData.trail = trail;
            scene.add(trail);

            scene.add(meteor);
            obstacles.push(meteor);
        }

        // --- SPAWN DE POWER-UPS MEJORADO ---
        function spawnPowerUp() {
            if (!isInitialized || !gameRunning || Math.random() > POWERUP_SPAWN_RATE) return;

            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const pos = new THREE.Vector3(
                currentPlanetRadius * Math.sin(phi) * Math.cos(theta),
                currentPlanetRadius * Math.sin(phi) * Math.sin(theta),
                currentPlanetRadius * Math.cos(phi)
            );

            const powerUpGeometry = new THREE.OctahedronGeometry(POWERUP_RADIUS, 0);
            const powerUpMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x00ffff,
                emissive: 0x00ffff,
                emissiveIntensity: 0.8,
                roughness: 0.2 // Más brillante
            });
            const powerUp = new THREE.Mesh(powerUpGeometry, powerUpMaterial);
            powerUp.position.copy(pos);
            powerUp.userData.originalPosition = pos.clone().multiplyScalar(originalPlanetRadius / currentPlanetRadius);
            const radial = pos.clone().normalize();
            const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), radial);
            powerUp.quaternion.copy(quat);
            powerUp.userData = { ...powerUp.userData, isPowerUp: true };
            scene.add(powerUp);
            powerUps.push(powerUp);
        }

        function updateObstacles(deltaTime) {
            const currentTime = clock.getElapsedTime();
            for (let lava of lavaSpots) {
                if (lava.material && lava.material.uniforms && lava.material.uniforms.time) {
                    lava.material.uniforms.time.value = currentTime;
                }
                lava.userData.pulseTime += deltaTime * 2;
                lava.scale.setScalar(1 + Math.sin(lava.userData.pulseTime) * 0.2); // Pulsación para intimidación
                if (lava.userData.smokes) {
                    lava.userData.smokes.forEach((smoke, index) => {
                        smoke.position.y += Math.sin(clock.getElapsedTime() * 2 + index) * 0.02;
                        smoke.rotation.y += deltaTime * 1;
                        smoke.scale.setScalar(1 + Math.sin(clock.getElapsedTime() * 3 + index) * 0.1); // Animación extra
                    });
                }
            }

            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                if (obs.userData.isMeteor) {
                    // Actualizar trail mejorado
                    if (obs.userData.trail) {
                        const points = obs.userData.trail.geometry.attributes.position.array;
                        const dir = obs.userData.direction;
                        for (let j = 0; j < points.length; j += 3) {
                            const dist = j / 3 * 2;
                            points[j] = obs.position.x - dir.x * dist;
                            points[j+1] = obs.position.y - dir.y * dist;
                            points[j+2] = obs.position.z - dir.z * dist;
                        }
                        obs.userData.trail.geometry.attributes.position.needsUpdate = true;
                    }

                    obs.position.add(obs.userData.direction.clone().multiplyScalar(obs.userData.speed * deltaTime));
                    
                    if (obs.position.length() <= currentPlanetRadius + METEOR_RADIUS) {
                        const impactPos = obs.position.clone().normalize().multiplyScalar(currentPlanetRadius);
                        createExplosion(impactPos);
                        spawnLava(impactPos);
                        if (obs.userData.trail) scene.remove(obs.userData.trail);
                        scene.remove(obs);
                        obstacles.splice(i, 1);
                        continue;
                    }
                }
            }

            // Actualizar power-ups (rotación y pulso más rápido para entretenimiento)
            for (let pu of powerUps) {
                pu.rotation.y += deltaTime * 4; // Más rápido
                pu.scale.setScalar(1 + Math.sin(clock.getElapsedTime() * 5) * 0.3); // Pulso más intenso
            }

            // Actualizar enemigos variados
            if (personaje) {
                const playerPos = personaje.position.clone();
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    if (enemy.material && enemy.material.uniforms && enemy.material.uniforms.time) {
                        enemy.material.uniforms.time.value = currentTime;
                    }
                    const enemyPos = enemy.position.clone();
                    const radial = enemyPos.clone().normalize();

                    let direction;
                    if (enemy.userData.behavior === 'chase' || enemy.userData.behavior === 'jump') {
                        direction = playerPos.clone().sub(enemyPos).normalize();
                        direction.projectOnPlane(radial);
                        if (direction.length() < 0.01) {
                            direction = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
                            direction.projectOnPlane(radial);
                        }
                        direction.normalize();
                    }

                    // Para jumper, agregar salto ocasional en dirección radial más frecuente
                    let jumpOffset = new THREE.Vector3(0, 0, 0);
                    if (enemy.userData.behavior === 'jump' && Math.random() < 0.05) { // Aumentado a 0.05
                        jumpOffset = radial.clone().multiplyScalar(4.0); // Salto más alto
                    }

                    const moveVec = direction.clone().multiplyScalar(enemy.userData.speed * deltaTime);
                    const newPos = enemyPos.clone().add(moveVec).add(jumpOffset).normalize().multiplyScalar(currentPlanetRadius + enemy.userData.height);

                    enemy.position.copy(newPos);
                    const newRadial = newPos.clone().normalize();
                    if (!enemy.userData.radial.equals(newRadial)) {
                        const correction = new THREE.Quaternion().setFromUnitVectors(enemy.userData.radial, newRadial);
                        enemy.quaternion.premultiply(correction);
                        enemy.userData.radial.copy(newRadial);
                    }

                    // Rotación para variedad más rápida
                    enemy.rotation.y += deltaTime * (2 + Math.random());

                    // Animación extra para fallback o todos, más dinámica
                    if (enemy.userData.fallback || true) {
                        enemy.rotation.x += deltaTime * enemy.userData.rotationSpeed * 0.8;
                        enemy.rotation.z += Math.sin(gameTime * 3 + i) * deltaTime * 0.3;  // Bobbing más rápido
                        // Shape changing: scale variation to simulate morphing
                        enemy.userData.shapeTime += deltaTime * 3;
                        const shapeScale = 1 + Math.sin(enemy.userData.shapeTime) * 0.3;
                        enemy.scale.setScalar(shapeScale);
                        // Actualiza trail si existe
                        if (enemy.userData.trail) {
                            const points = enemy.userData.trail.geometry.attributes.position.array;
                            points[0] = enemy.position.x; points[1] = enemy.position.y; points[2] = enemy.position.z;
                            for (let j = 1; j < points.length / 3; j++) {
                                const dist = j * 1;
                                points[j*3] = enemy.position.x - radial.x * dist;
                                points[j*3+1] = enemy.position.y - radial.y * dist;
                                points[j*3+2] = enemy.position.z - radial.z * dist;
                            }
                            enemy.userData.trail.geometry.attributes.position.needsUpdate = true;
                        }
                    }
                }
            }
        }

        function createExplosion(position) {
            const explosionGeometry = new THREE.SphereGeometry(EXPLOSION_RADIUS, 32, 32);
            const explosionMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFF4500, 
                transparent: true, 
                opacity: 0.9 
            });
            const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);

            explosion.position.copy(position);
            explosion.userData = { 
                startTime: clock.getElapsedTime(), 
                duration: EXPLOSION_DURATION, 
                isExplosion: true 
            };

            scene.add(explosion);
            explosions.push(explosion);

            // Partículas de explosión para belleza, más partículas para entretenimiento
            for (let k = 0; k < 30; k++) { // Aumentado a 30
                const particleGeo = new THREE.SphereGeometry(0.1, 4, 4);
                const particleMat = new THREE.MeshBasicMaterial({
                    color: 0xFF6600,
                    transparent: true,
                    opacity: 1
                });
                const particle = new THREE.Mesh(particleGeo, particleMat);
                particle.position.copy(position);
                const dir = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
                particle.userData = { velocity: dir.multiplyScalar(15), life: 1.5 }; // Velocidad y vida aumentadas
                scene.add(particle);
                explosions.push(particle);
            }
        }

        // --- DETECCIÓN DE COLISIONES ESTÁTICAS ---
        function checkStaticCollisions(newPos) {
            for (let staticObj of staticObstacles) {
                let collisionDist = STATIC_COLLISION_DISTANCE;
                if (staticObj.userData && staticObj.userData.isTree) {
                    collisionDist = TREE_COLLISION_DISTANCE;
                }
                const dist = newPos.distanceTo(staticObj.position);
                if (dist < collisionDist) {
                    return true;
                }
            }
            return false;
        }

        function checkCollisions(deltaTime) {
            if (!personaje || !gameRunning || !isInitialized) return;

            const characterPos = personaje.position;

            // Colisión con meteoritos
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                if (obs.userData.isMeteor) {
                    const dist = characterPos.distanceTo(obs.position);
                    if (dist < COLLISION_DISTANCE && !invulnerable) {
                        takeHit();
                        createExplosion(obs.position);
                        if (obs.userData.trail) scene.remove(obs.userData.trail);
                        scene.remove(obs);
                        obstacles.splice(i, 1);
                    }
                }
            }

            // Colisión con explosiones
            for (let i = explosions.length - 1; i >= 0; i--) {
                const exp = explosions[i];
                if (exp.userData.isExplosion && exp.geometry.parameters.radius === EXPLOSION_RADIUS) {
                    const dist = characterPos.distanceTo(exp.position);
                    if (dist < BLAST_DAMAGE_RADIUS && !invulnerable) {
                        takeHit();
                    }
                }
            }

            // Colisión con power-ups (distancia aumentada)
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const pu = powerUps[i];
                const dist = characterPos.distanceTo(pu.position);
                if (dist < COLLISION_DISTANCE + 0.5) { // Más fácil de recoger
                    heal();
                    score += SCORE_PER_POWERUP;
                    scene.remove(pu);
                    powerUps.splice(i, 1);
                }
            }

            // Colisión con enemigos
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const dist = characterPos.distanceTo(enemy.position);
                if (dist < COLLISION_DISTANCE && !invulnerable) {
                    takeHit();
                    score += SCORE_PER_ENEMY; // Puntos por destruir enemigo
                    if (enemy.userData.trail) scene.remove(enemy.userData.trail);
                    scene.remove(enemy);
                    enemies.splice(i, 1);
                }
            }

            // Daño de lava mejorado (distancia aumentada a 1.5 para cubrir mejor)
            if (!lavaSpots || lavaSpots.length === 0) return;
            let inLavaNow = false;
            for (let lava of lavaSpots) {
                if (lava && lava.position && characterPos.distanceTo(lava.position) < 1.5) { // Ajustado para tamaño más pequeño
                    inLavaNow = true;
                    break;
                }
            }
            if (inLavaNow && !inLava) {
                lavaDamageTimer = 0;
            }
            inLava = inLavaNow;
            if (inLava && !invulnerable) {
                lavaDamageTimer += deltaTime;
                if (lavaDamageTimer >= LAVA_DAMAGE_INTERVAL) {
                    takeHit();
                    lavaDamageTimer = 0;
                }
            }
        }

        function takeHit() {
            if (!gameRunning) return;
            hits++;
            document.getElementById('hits').textContent = hits;
            invulnerable = true;
            invulnTimer = INVULN_DURATION;
            if (hits >= MAX_HITS) {
                endGame();
            }
        }

        function heal() {
            if (hits > 0) {
                hits--;
                document.getElementById('hits').textContent = hits;
            }
        }

        function update() {
            const deltaTime = clock.getDelta();
            if (gameRunning && isInitialized) {
                gameTime += deltaTime;
                score += SCORE_PER_SECOND * deltaTime;

                // Auto shrink
                if (gameTime - lastAutoShrinkTime >= AUTO_SHRINK_INTERVAL) {
                    shrinkPlanet();
                    lastAutoShrinkTime = gameTime;
                }

                const currentSecond = Math.floor(gameTime);
                if (currentSecond > lastSecond) {
                    METEOR_SPAWN_RATE = Math.min(0.06, METEOR_SPAWN_RATE + 0.003); // Aumento más rápido
                    ENEMY_SPAWN_RATE = Math.min(0.012, ENEMY_SPAWN_RATE + 0.0008); // Aumento más rápido sin exceder
                    lastSecond = currentSecond;
                }

                const currentInterval = Math.floor(gameTime / DIFFICULTY_INCREASE_INTERVAL);
                if (currentInterval > lastDifficultyIncrease) {
                    POWERUP_SPAWN_RATE = Math.min(0.0003, POWERUP_SPAWN_RATE + 0.0001); // Menos powerups
                    lastDifficultyIncrease = currentInterval;
                }

                if (invulnerable) {
                    invulnTimer -= deltaTime;
                    if (invulnTimer <= 0) {
                        invulnerable = false;
                    }
                }

                spawnMeteor();
                spawnEnemy(); // Nuevo: spawn de enemigos
                spawnPowerUp();
                updateObstacles(deltaTime);
                checkCollisions(deltaTime);
            }

            if (mixer) mixer.update(deltaTime);
            if (personaje && gameRunning) {
                personaje.visible = !invulnerable || (Math.floor(clock.getElapsedTime() * 10) % 2 === 0);
                updateCharacter(deltaTime);
                if (personaje) {
                    const adjustedPos = personaje.position.clone().normalize().multiplyScalar(currentPlanetRadius + CHARACTER_HEIGHT);
                    personaje.position.copy(adjustedPos);
                    const newRadial = adjustedPos.normalize();
                    if (!previousRadial.equals(newRadial)) {
                        const correction = new THREE.Quaternion().setFromUnitVectors(previousRadial, newRadial);
                        personaje.quaternion.premultiply(correction);
                        previousRadial.copy(newRadial);
                    }
                }
                updateCamera();
            }

            // Actualizar minimapa
            minimapAngle += deltaTime * 0.2;
            minimapCamera.position.x = Math.sin(minimapAngle) * currentPlanetRadius * 3; // Usar currentRadius
            minimapCamera.position.z = Math.cos(minimapAngle) * currentPlanetRadius * 3;
            minimapCamera.lookAt(0, 0, 0);

            // Actualizar explosiones y partículas
            for (let i = explosions.length - 1; i >= 0; i--) {
                const exp = explosions[i];
                if (exp.userData.isExplosion) {
                    if (exp.geometry.parameters.radius === EXPLOSION_RADIUS) {
                        const elapsed = clock.getElapsedTime() - exp.userData.startTime;
                        const progress = elapsed / exp.userData.duration;
                        if (progress >= 1) {
                            scene.remove(exp);
                            explosions.splice(i, 1);
                        } else {
                            exp.scale.setScalar(1 + progress * 3);
                            exp.material.opacity = Math.max(0, 0.9 * (1 - progress));
                            if (progress > 0.5) {
                                exp.material.color.setHSL(0, 1, (1 - progress) * 0.5);
                            }
                        }
                    } else {
                        // Partículas
                        exp.userData.life -= deltaTime;
                        if (exp.userData.life <= 0) {
                            scene.remove(exp);
                            explosions.splice(i, 1);
                        } else {
                            exp.position.add(exp.userData.velocity.clone().multiplyScalar(deltaTime));
                            exp.material.opacity = exp.userData.life;
                            exp.scale.setScalar(1 - exp.userData.life);
                        }
                    }
                }
            }

            // Update snow particles continuously
            if (window.snow) {
                const positions = window.snow.geometry.attributes.position.array;
                const velocities = window.snow.geometry.attributes.velocity.array;
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i] += velocities[i] * deltaTime;
                    positions[i+1] += velocities[i+1] * deltaTime;
                    positions[i+2] += velocities[i+2] * deltaTime;
                    
                    // Reset if too close to center
                    const len = Math.sqrt(positions[i]**2 + positions[i+1]**2 + positions[i+2]**2);
                    if (len < currentPlanetRadius * 0.9) {
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos(2 * Math.random() - 1);
                        const r = currentPlanetRadius * 1.2;
                        positions[i] = r * Math.sin(phi) * Math.cos(theta);
                        positions[i+1] = r * Math.sin(phi) * Math.sin(theta);
                        positions[i+2] = r * Math.cos(phi);
                        
                        const dir = new THREE.Vector3(positions[i], positions[i+1], positions[i+2]).normalize();
                        const speed = 0.5 + Math.random() * 1.0;
                        velocities[i] = -dir.x * speed;
                        velocities[i+1] = -dir.y * speed;
                        velocities[i+2] = -dir.z * speed;
                    }
                }
                window.snow.geometry.attributes.position.needsUpdate = true;
            }
        }

        function updateCharacter(deltaTime) {
            if (!personaje) return;
            const currentRadial = personaje.position.clone().normalize();
            const isMoving = keysPressed['w'] || keysPressed['arrowup'];

            if (keysPressed['a'] || keysPressed['arrowleft']) {
                const angle = -TURN_SPEED * deltaTime;
                const rotation = new THREE.Quaternion().setFromAxisAngle(currentRadial, angle);
                personaje.quaternion.premultiply(rotation);
            }
            if (keysPressed['d'] || keysPressed['arrowright']) {
                const angle = TURN_SPEED * deltaTime;
                const rotation = new THREE.Quaternion().setFromAxisAngle(currentRadial, angle);
                personaje.quaternion.premultiply(rotation);
            }

            if (keysPressed['s'] || keysPressed['arrowdown']) {
                const angle = Math.PI * deltaTime * 2;
                const rotation = new THREE.Quaternion().setFromAxisAngle(currentRadial, angle);
                personaje.quaternion.premultiply(rotation);
            }

            const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(personaje.quaternion);
            forward.projectOnPlane(currentRadial).normalize();

            if (isMoving) {
                const radius = currentPlanetRadius + CHARACTER_HEIGHT;
                const moveVector = forward.clone().multiplyScalar(FORWARD_SPEED * deltaTime);
                const oldPos = personaje.position.clone();
                const tentativeNewPos = oldPos.clone().add(moveVector).normalize().multiplyScalar(radius);
                
                if (!checkStaticCollisions(tentativeNewPos)) {
                    const oldRadial = previousRadial.clone();
                    personaje.position.copy(tentativeNewPos);
                    const newRadial = tentativeNewPos.clone().normalize();

                    if (actions['Walk']) setActiveAction(actions['Walk']);

                    if (!oldRadial.equals(newRadial)) {
                        const correction = new THREE.Quaternion().setFromUnitVectors(oldRadial, newRadial);
                        personaje.quaternion.premultiply(correction);
                    }

                    previousRadial.copy(newRadial);
                } else {
                    if (actions['Idle']) setActiveAction(actions['Idle']);
                }
            } else {
                if (actions['Idle']) setActiveAction(actions['Idle']);
            }
        }

        function updateCamera() {
            if (!personaje) return;
            const characterUp = personaje.position.clone().normalize();
            const cameraOffset = new THREE.Vector3(0, CAMERA_HEIGHT, -CAMERA_DISTANCE * 0.4); 
            cameraOffset.applyMatrix4(personaje.matrixWorld);

            const lookAtTarget = new THREE.Vector3().setFromMatrixPosition(personaje.matrixWorld);
            lookAtTarget.add(characterUp.multiplyScalar(4));
            
            camera.position.lerp(cameraOffset, 0.05);
            camera.up.copy(characterUp);
            camera.lookAt(lookAtTarget);
        }

        function render() {
            requestAnimationFrame(render);
            update();
            renderer.render(scene, camera);
            minimapRenderer.render(scene, minimapCamera);
        }
    </script>
</body>
</html>