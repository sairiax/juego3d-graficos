<!DOCTYPE html>
<html>
<head>
    <title>Personaje en Planeta con Three.js - Juego de Supervivencia</title>
    <style>
        body { 
            margin: 0; 
            font-family: 'Arial', sans-serif; 
            background: #000; 
            overflow: hidden;
        }
        #container { 
            width: 100%; 
            height: 100vh; 
            position: relative; 
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00ff00;
            box-shadow: 0 0 15px rgba(0,255,0,0.6);
            font-size: 14px;
            min-width: 180px;
        }
        #healthBar {
            width: 150px;
            height: 20px;
            background: rgba(0,0,0,0.5);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }
        #healthFill {
            height: 100%;
            background: linear-gradient(to right, #00ff00, #ff0000);
            width: 100%;
            transition: width 0.3s ease;
        }
        #time, #hits, #score, #planetRadius {
            font-weight: bold;
            text-shadow: 0 0 5px #00ff00;
        }
        #invulnIndicator {
            color: #00ffff;
            font-size: 12px;
            text-shadow: 0 0 5px #00ffff;
            display: none;
        }
        #lavaWarning {
            color: #ff4500;
            font-size: 12px;
            text-shadow: 0 0 5px #ff4500;
            display: none;
        }
        #shrinkCooldown {
            color: #ffff00;
            font-size: 12px;
            text-shadow: 0 0 5px #ffff00;
            display: none;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            z-index: 200;
            background: rgba(0,0,0,0.9);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #ff0000;
            box-shadow: 0 0 20px rgba(255,0,0,0.6);
            display: none;
            font-size: 18px;
        }
        #winScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            z-index: 200;
            background: rgba(0,0,0,0.9);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #00ff00;
            box-shadow: 0 0 20px rgba(0,255,0,0.6);
            display: none;
            font-size: 18px;
        }
        #winScreen h2 {
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
        }
        #gameOver h2 {
            color: #ff0000;
            text-shadow: 0 0 10px #ff0000;
        }
        #restartBtn {
            background: #00ff00;
            color: black;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 10px;
        }
        #restartBtn:hover {
            background: #00cc00;
        }
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #ffff00;
            box-shadow: 0 0 15px rgba(255,255,0,0.6);
            font-size: 14px;
            max-width: 300px;
        }
        #minimap {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 150px;
            height: 150px;
            background: rgba(0,0,0,0.8);
            border-radius: 50%;
            border: 2px solid #00ffff;
            overflow: hidden;
            box-shadow: 0 0 15px rgba(0,255,255,0.5);
        }
        #minimap canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #tips {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: white;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 10px;
            border: 2px solid #ff00ff;
            box-shadow: 0 0 15px rgba(255,0,255,0.5);
            font-size: 12px;
            max-width: 200px;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            z-index: 200;
            background: rgba(0,0,0,0.9);
            padding: 30px;
            border-radius: 15px;
            display: block;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="ui">
            <div>Tiempo: <span id="time">0</span>s</div>
            <div>Puntuacion: <span id="score">0</span></div>
            <div>Golpes: <span id="hits">0</span>/3</div>
            <div id="healthBar">
                <div id="healthFill"></div>
            </div>
            <div>Radio Planeta: <span id="planetRadius">40</span></div>
            <div id="invulnIndicator">¡Invulnerable!</div>
            <div id="lavaWarning">¡En Lava! Daño continuo...</div>
            <div id="shrinkCooldown">¡Espera 10s para encoger de nuevo!</div>
        </div>
        <div id="instructions">
            <strong>Controles:</strong><br>
            W/Flecha ↑: Mover adelante<br>
            A/D o ←/→: Girar<br>
            S/Flecha ↓: Revertir direccion<br>
            <strong>Espacio: Encoger planeta (cada 10s)</strong><br>
            <br>Sobrevive evitando meteoritos. ¡Colecciona power-ups para curarte y ganar puntos extra!<br>
            <small>¡Encoge el planeta hasta radio 5 para ganar! Evita las zonas de lava rojas brillantes y los enemigos variados que te persiguen.</small>
        </div>
        <div id="tips">
            <strong>Consejos:</strong><br>
            - Meteoritos dejan rastro naranja.<br>
            - Explosiones dañan en área.<br>
            - Power-ups azules curan.<br>
            - Lava daña cada segundo.<br>
            - ¡Enemigos rojos te siguen! Destrúyelos al chocar para puntos. Hay tipos rápidos, grandes y saltadores.
        </div>
        <div id="minimap"></div>
        <div id="gameOver">
            <h2>¡Game Over!</h2>
            <p>Tiempo sobrevivido: <span id="finalTime">0</span>s</p>
            <p>Puntuacion final: <span id="finalScore">0</span></p>
            <p>Mejor puntuacion: <span id="bestScore">0</span></p>
            <button id="restartBtn" onclick="location.reload()">Reiniciar</button>
        </div>
        <div id="winScreen">
            <h2>¡Victoria!</h2>
            <p>Tiempo: <span id="winTime">0</span>s</p>
            <p>Puntuacion: <span id="winScore">0</span></p>
            <button id="restartBtn" onclick="location.reload()">Jugar de nuevo</button>
        </div>
        <div id="loading">
            <h2>Cargando modelos...</h2>
            <p>Por favor espera.</p>
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="js/FBXLoader.js"></script>
    <script src="js/inflate.min.js"></script>

    <script>
        // --- REFERENCIAS GLOBALES ---
        var renderer, scene, camera, planeta, previousRadial, cube;
        var clock = new THREE.Clock();

        // --- GESTIÓN DE ANIMACIÓN ---
        var mixer;
        const actions = {}; 
        let activeAction; 

        // --- ESTADO DEL JUEGO ---
        let gameRunning = true;
        let gameTime = 0;
        let score = 0;
        let hits = 0;
        const MAX_HITS = 3;
        let obstacles = [];
        let staticObstacles = []; // Nuevo: para rocas y árboles
        let lavaSpots = []; // Zonas de lava como peligro adicional
        let explosions = [];
        let powerUps = [];
        let enemies = []; // Nuevo: enemigos que persiguen al jugador
        let bestScore = localStorage.getItem('bestScore') || 0;

        // Cooldown para encoger
        let lastShrinkTime = 0;
        const SHRINK_COOLDOWN = 10; // 10 segundos

        // Invulnerabilidad
        let invulnerable = false;
        let invulnTimer = 0;
        const INVULN_DURATION = 4;

        // Daño de lava
        let inLava = false;
        let lavaDamageTimer = 0;
        const LAVA_DAMAGE_INTERVAL = 0.5; // Reducido para daño más frecuente

        // Seguimiento de carga de modelos
        const modelsToLoad = 7; // player model + 2 anims + 3 enemies + tree
        let modelsLoaded = 0;
        let isInitialized = false;

        // --- CONSTANTES DE CONFIGURACIÓN ---
        const originalPlanetRadius = 40;
        let currentPlanetRadius = originalPlanetRadius;
        const CHARACTER_HEIGHT = 0.5;
        const CHARACTER_SCALE = 0.02;
        const FORWARD_SPEED = 10.0;
        const TURN_SPEED = 2.0;
        const CAMERA_DISTANCE = 1000;
        const CAMERA_HEIGHT = 700;
        const STATIC_COLLISION_DISTANCE = 0.8;
        const TREE_COLLISION_DISTANCE = 5;
        const SHRINK_AMOUNT = 1.0;
        const WIN_RADIUS = 5;
        const BLAST_DAMAGE_RADIUS = 3.0;

        // --- CONFIGURACIÓN DE OBSTÁCULOS MEJORADA ---
        let METEOR_SPAWN_RATE = 0.01; // Aumentado para más dificultad inicial
        const METEOR_SPEED = 30; // Aumentado para que lleguen más rápido y alcancen
        const METEOR_RADIUS = 1;
        const EXPLOSION_RADIUS = 5;
        const EXPLOSION_DURATION = 1;
        const COLLISION_DISTANCE = 2.5; // Aumentado para colisiones más fáciles con meteoritos y enemigos
        let POWERUP_SPAWN_RATE = 0.001;
        const POWERUP_RADIUS = 0.5;
        const SCORE_PER_SECOND = 10;
        const SCORE_PER_POWERUP = 100;
        const SCORE_PER_ENEMY = 50; // Puntos por destruir enemigo
        const DIFFICULTY_INCREASE_INTERVAL = 10;
        let lastDifficultyIncrease = 0;
        let lastSecond = 0;

        // Configuración de enemigos variados
        let ENEMY_SPAWN_RATE = 0.01; // Aumentado para test (más enemigos)
        const ENEMY_SPEED = 1.5; // Velocidad base
        const ENEMY_RADIUS = 0.8;
        const ENEMY_TYPES = [
            { name: 'chaser', model: 'models/e1.glb', scale: 2.0, color: 0xff0000, speed: 1.5, behavior: 'chase' },
            { name: 'brute', model: 'models/e2.glb', scale: 1.5, color: 0x800000, speed: 0.8, behavior: 'chase' },
            { name: 'jumper', model: 'models/e3.glb', scale: 1.8, color: 0xff00ff, speed: 1.2, behavior: 'jump' }
        ];
        
        // Cache de modelos de enemigos
        const enemyModels = {};

        // Minimap
        let minimapRenderer, minimapCamera;
        let minimapAngle = 0;

        // --- ESTADO DEL TECLADO ---
        var keysPressed = {};
        document.addEventListener('keydown', (event) => {
            keysPressed[event.key.toLowerCase()] = true;
            if (event.key.toLowerCase() === ' ') {
                event.preventDefault();
                if (gameRunning && isInitialized) {
                    attemptShrinkPlanet();
                }
            }
        }, false);
        document.addEventListener('keyup', (event) => keysPressed[event.key.toLowerCase()] = false, false);

        let personaje;

        init();
        loadPlaneta(originalPlanetRadius, 'https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg');
        loadPersonaje('models/c.fbx', CHARACTER_SCALE);
        preloadEnemyModels();
        render();

        function modelLoaded() {
            modelsLoaded++;
            if (modelsLoaded === modelsToLoad) {
                isInitialized = true;
                document.getElementById('loading').style.display = 'none';
                console.log('All models loaded');
            }
        }

        function init() {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(new THREE.Color(0x000011)); // Fondo más estrellado
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.getElementById('container').appendChild(renderer.domElement);

            // Minimap setup mejorado
            const minimapDiv = document.getElementById('minimap');
            minimapRenderer = new THREE.WebGLRenderer({ antialias: false });
            minimapRenderer.setSize(150, 150);
            minimapRenderer.setClearColor(0x000022);
            minimapRenderer.shadowMap.enabled = false;
            minimapDiv.appendChild(minimapRenderer.domElement);

            minimapCamera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            minimapCamera.position.set(0, 0, originalPlanetRadius * 3);
            minimapCamera.lookAt(0, 0, 0);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            
            camera.position.set(0, originalPlanetRadius + CAMERA_HEIGHT + 10, 20);
            camera.lookAt(0, originalPlanetRadius, 0);
            
            // Estrellas mejoradas con más brillo
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 30000; // Más estrellas
            const positions = new Float32Array(starCount * 3);
            const sizes = new Float32Array(starCount);
            const colors = new Float32Array(starCount * 3);
            for (let i = 0; i < starCount; i++) {
                const i3 = i * 3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 800 + Math.random() * 1200;
                positions[i3] = r * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = r * Math.cos(phi);
                
                sizes[i] = Math.random() * 4 + 1; // Tamaños variados
                
                const color = new THREE.Color();
                color.setHSL(Math.random() * 0.1 + 0.55, 0.7, Math.random() * 0.3 + 0.7); // Colores más vibrantes
                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;
            }
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            const starMaterial = new THREE.PointsMaterial({ 
                size: 3, 
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                sizeAttenuation: true 
            });
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
            
            // Iluminación mejorada para más belleza
            scene.add(new THREE.AmbientLight(0x404040, 0.4)); // Reducido para contraste
            
            const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x444444, 0.8); // Cielo azul
            hemiLight.position.set(0, 200, 0);
            scene.add(hemiLight);
            
            const sunLight = new THREE.DirectionalLight(0xffddaa, 1.5); // Intensidad reducida
            sunLight.position.set(200, 150, 100);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 4096;
            sunLight.shadow.mapSize.height = 4096;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 1000;
            sunLight.shadow.camera.left = -originalPlanetRadius * 3;
            sunLight.shadow.camera.right = originalPlanetRadius * 3;
            sunLight.shadow.camera.top = originalPlanetRadius * 3;
            sunLight.shadow.camera.bottom = -originalPlanetRadius * 3;
            sunLight.shadow.bias = -0.0001;
            sunLight.shadow.normalBias = 0.0005;
            scene.add(sunLight);

            // Sol visible con glow mejorado
            const sunGeometry = new THREE.SphereGeometry(8, 64, 64);
            const sunMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffff88,
                transparent: true,
                opacity: 0.95
            });
            const sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sun.position.copy(sunLight.position);
            scene.add(sun);

            const glowGeometry = new THREE.SphereGeometry(25, 64, 64);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffaa00, 
                transparent: true, 
                opacity: 0.5,
                side: THREE.BackSide 
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.copy(sunLight.position);
            scene.add(glow);

            const haloGeometry = new THREE.TorusGeometry(30, 2, 16, 100);
            const haloMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.3 
            });
            const halo = new THREE.Mesh(haloGeometry, haloMaterial);
            halo.position.copy(sunLight.position);
            halo.rotation.x = Math.PI / 2;
            scene.add(halo);

            function animateHalo() {
                if (halo) halo.rotation.z += 0.005;
                requestAnimationFrame(animateHalo);
            }
            animateHalo();

            const sunPointLight = new THREE.PointLight(0xffddaa, 0.8, 300); // Reducido
            sunPointLight.position.copy(sunLight.position);
            scene.add(sunPointLight);

            // Partículas de polvo atmosférico para belleza
            const dustGeometry = new THREE.BufferGeometry();
            const dustCount = 1000;
            const dustPositions = new Float32Array(dustCount * 3);
            for (let i = 0; i < dustCount; i++) {
                const i3 = i * 3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = originalPlanetRadius * (1 + Math.random() * 0.1); // Cerca del planeta
                dustPositions[i3] = r * Math.sin(phi) * Math.cos(theta);
                dustPositions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                dustPositions[i3 + 2] = r * Math.cos(phi);
            }
            dustGeometry.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));
            const dustMaterial = new THREE.PointsMaterial({
                color: 0xaaaaaa,
                size: 0.5,
                transparent: true,
                opacity: 0.3
            });
            const dust = new THREE.Points(dustGeometry, dustMaterial);
            scene.add(dust);
            window.dust = dust; // Exponer para acceso global en shrinkPlanet

            window.addEventListener('resize', updateAspectRatio);

            setInterval(updateUI, 100);
        }

        function loadPlaneta(radio, texturaURL) {
            const geometria = new THREE.SphereGeometry(radio, 128, 128);
            const textura = new THREE.TextureLoader().load(texturaURL);
            const material = new THREE.MeshStandardMaterial({ 
                map: textura,
                normalMap: textura, // Añadir normal map para relieve (usando la misma textura como approx)
                normalScale: new THREE.Vector2(0.5, 0.5),
                metalness: 0.05, // Menos metálico
                roughness: 0.9 // Más rugoso para realismo
            });
            planeta = new THREE.Mesh(geometria, material);
            planeta.receiveShadow = true;
            planeta.castShadow = true;
            planeta.userData.originalRadius = radio;
            scene.add(planeta);

            // Bump map simulado para textura al encoger
            planeta.userData.originalScale = 1.0;

            // Añadir rocas con mejor material
            const numRocks = 300; // Más rocas
            for (let i = 0; i < numRocks; i++) {
                const rockRadius = 0.3 + Math.random() * 0.7;
                const rockGeo = new THREE.DodecahedronGeometry(rockRadius, 1); // Mejor forma para rocas
                const rockMat = new THREE.MeshStandardMaterial({ 
                    color: new THREE.Color().setHSL(0.08 + Math.random() * 0.08, 0.4, 0.2 + Math.random() * 0.3),
                    roughness: 0.9,
                    metalness: 0.1
                });
                const rock = new THREE.Mesh(rockGeo, rockMat);
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const pos = new THREE.Vector3(
                    radio * Math.sin(phi) * Math.cos(theta),
                    radio * Math.sin(phi) * Math.sin(theta),
                    radio * Math.cos(phi)
                );
                const offset = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                ).normalize().multiplyScalar(rockRadius);
                pos.add(offset);
                rock.position.copy(pos);
                rock.userData.originalPosition = pos.clone();
                rock.castShadow = true;
                rock.receiveShadow = true;
                scene.add(rock);
                staticObstacles.push(rock);
            }

            // Load tree model instead of procedural
            const treeLoader = new THREE.GLTFLoader();
            treeLoader.load('models/tree.glb', function(gltf) {
                const treeTemplate = gltf.scene.clone(); // Clone to avoid sharing
                treeTemplate.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                treeTemplate.scale.set(3, 3, 3); // Escala razonable para GLTF (ajusta según el tamaño de tu modelo; prueba 0.1-2.0)

                const numTrees = 200; // Reducido para mejor rendimiento con escalas grandes
                for (let i = 0; i < numTrees; i++) {
                    const tree = treeTemplate.clone();
                    tree.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const pos = new THREE.Vector3(
                        radio * Math.sin(phi) * Math.cos(theta),
                        radio * Math.sin(phi) * Math.sin(theta),
                        radio * Math.cos(phi)
                    );
                    tree.position.copy(pos);
                    const radial = pos.clone().normalize();
                    const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), radial);
                    tree.quaternion.copy(quat);
                    tree.castShadow = true;
                    tree.receiveShadow = true;
                    // Offset para evitar que se entierren
                    const treeOffset = CHARACTER_HEIGHT + 4;
                    tree.position.add(radial.clone().multiplyScalar(treeOffset));
                    tree.userData = {
                        isTree: true,
                        radial: radial.clone(),
                        offset: treeOffset
                    };
                    scene.add(tree);
                    staticObstacles.push(tree);
                }
                console.log('Trees loaded from GLTF');
                modelLoaded();
            }, undefined, function(error) {
                console.error('Error loading tree model:', error);
                createProceduralTrees(radio); // Fallback a procedural si GLTF falla
            });

            // Zonas de lava mejoradas con glow y partículas
            const numLava = 200; // Más zonas
            for (let i = 0; i < numLava; i++) {
                const lavaRadius = 1.0; // Aumentado para más cobertura
                const lavaGeo = new THREE.SphereGeometry(lavaRadius, 16, 16);
                const lavaMat = new THREE.MeshStandardMaterial({ 
                    color: 0xff4500,
                    emissive: 0xff6600,
                    emissiveIntensity: 0.8 // Más brillante
                });
                const lava = new THREE.Mesh(lavaGeo, lavaMat);
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const pos = new THREE.Vector3(
                    radio * Math.sin(phi) * Math.cos(theta),
                    radio * Math.sin(phi) * Math.sin(theta),
                    radio * Math.cos(phi)
                );
                lava.position.copy(pos);
                lava.userData.originalPosition = pos.clone();
                const radial = pos.clone().normalize();
                const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), radial);
                lava.quaternion.copy(quat);
                lava.castShadow = true;
                lava.receiveShadow = true;
                scene.add(lava);
                lavaSpots.push(lava);

                // Partículas de humo para lava
                const smokeGeo = new THREE.SphereGeometry(0.2, 4, 4);
                const smokeMat = new THREE.MeshBasicMaterial({
                    color: 0x444444,
                    transparent: true,
                    opacity: 0.3
                });
                const smoke = new THREE.Mesh(smokeGeo, smokeMat);
                smoke.position.copy(lava.position);
                smoke.position.add(new THREE.Vector3(0, lavaRadius + 0.5, 0));
                scene.add(smoke);
                lava.userData.smoke = smoke;
            }
        }

        function createProceduralTrees(radio) {
            // Fallback procedural trees
            const numTrees = 100;
            for (let i = 0; i < numTrees; i++) {
                const treeHeight = 3 + Math.random() * 2;
                const trunkGeo = new THREE.CylinderGeometry(0.2, 0.3, 1.5, 8);
                const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                const foliageGeo = new THREE.SphereGeometry(1.5, 8, 8);
                const foliageMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });
                const foliage = new THREE.Mesh(foliageGeo, foliageMat);
                foliage.position.y = 1.5;
                const tree = new THREE.Group();
                tree.add(trunk);
                tree.add(foliage);
                tree.scale.set(1, treeHeight / 3, 1);

                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const pos = new THREE.Vector3(
                    radio * Math.sin(phi) * Math.cos(theta),
                    radio * Math.sin(phi) * Math.sin(theta),
                    radio * Math.cos(phi)
                );
                tree.position.copy(pos);
                const radial = pos.clone().normalize();
                const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), radial);
                tree.quaternion.copy(quat);
                const treeOffset = CHARACTER_HEIGHT;
                tree.position.add(radial.clone().multiplyScalar(treeOffset));
                tree.userData = {
                    isTree: true,
                    radial: radial.clone(),
                    offset: treeOffset
                };
                tree.castShadow = true;
                tree.receiveShadow = true;
                scene.add(tree);
                staticObstacles.push(tree);
            }
            modelLoaded();
        }

        function spawnLava(position) {
            const lavaRadius = 1.0;
            const lavaGeo = new THREE.SphereGeometry(lavaRadius, 16, 16);
            const lavaMat = new THREE.MeshStandardMaterial({ 
                color: 0xff4500,
                emissive: 0xff6600,
                emissiveIntensity: 0.8
            });
            const lava = new THREE.Mesh(lavaGeo, lavaMat);
            const radial = position.clone().normalize();
            lava.position.copy(position);
            const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), radial);
            lava.quaternion.copy(quat);
            lava.castShadow = true;
            lava.receiveShadow = true;
            scene.add(lava);
            lavaSpots.push(lava);
            lava.userData.originalPosition = position.clone().multiplyScalar(originalPlanetRadius / currentPlanetRadius);

            // Partículas de humo para lava
            const smokeGeo = new THREE.SphereGeometry(0.2, 4, 4);
            const smokeMat = new THREE.MeshBasicMaterial({
                color: 0x444444,
                transparent: true,
                opacity: 0.3
            });
            const smoke = new THREE.Mesh(smokeGeo, smokeMat);
            smoke.position.copy(lava.position);
            smoke.position.add(new THREE.Vector3(0, lavaRadius + 0.5, 0));
            scene.add(smoke);
            lava.userData.smoke = smoke;
        }

        // --- SPAWN DE ENEMIGOS VARIADOS ---
        function preloadEnemyModels() {
            const loader = new THREE.GLTFLoader();
            ENEMY_TYPES.forEach(type => {
                loader.load(type.model, function(gltf) {
                    const model = gltf.scene.clone();
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            // Aplicar color tintado
                            if (child.material) {
                                child.material = child.material.clone();
                                child.material.color.set(type.color);
                                child.material.emissive = new THREE.Color(type.color);
                                child.material.emissiveIntensity = 0.3;
                            }
                        }
                    });
                    enemyModels[type.name] = model;
                    console.log(`Modelo de enemigo ${type.name} cargado`);
                    modelLoaded();
                }, undefined, function(error) {
                    console.error(`Error cargando modelo ${type.model}:`, error);
                    // Fallback: Crear geometría procedural simple
                    const fallbackGeometry = type.name === 'chaser' ? 
                        new THREE.SphereGeometry(0.5, 8, 8) :  // Esfera para chaser
                        (type.name === 'brute' ? 
                            new THREE.CylinderGeometry(0.6, 0.8, 1.2, 8) :  // Cilindro ancho para brute
                            new THREE.ConeGeometry(0.4, 1.5, 8)  // Cono para jumper
                        );
                    const fallbackMaterial = new THREE.MeshStandardMaterial({ 
                        color: type.color,
                        emissive: type.color,
                        emissiveIntensity: 0.5  // Glow fuerte para visibilidad
                    });
                    const fallbackModel = new THREE.Mesh(fallbackGeometry, fallbackMaterial);
                    fallbackModel.userData = { fallback: true };  // Marcar como fallback
                    enemyModels[type.name] = fallbackModel;
                    console.log(`Fallback procedural creado para enemigo ${type.name}`);
                    modelLoaded();
                });
            });
        }

        function spawnEnemy() {
            if (!gameRunning || !isInitialized || Math.random() > ENEMY_SPAWN_RATE) return;

            const type = ENEMY_TYPES[Math.floor(Math.random() * ENEMY_TYPES.length)];
            const modelTemplate = enemyModels[type.name];
            if (!modelTemplate) return;

            // TEST: Reemplaza con geometría simple para visibilidad (cambia true a false para usar modelo real)
            let enemy;
            if (true) {  // Cambia a false para usar modelo real
                // Geometría fallback: esfera roja brillante para chaser, cilindro marrón para brute, cono magenta para jumper
                const geo = type.name === 'chaser' ? new THREE.SphereGeometry(0.8, 8, 8) :
                            type.name === 'brute' ? new THREE.CylinderGeometry(0.6, 1.0, 1.5, 8) :
                            new THREE.ConeGeometry(0.5, 2.0, 8);
                const mat = new THREE.MeshStandardMaterial({
                    color: type.color,
                    emissive: type.color,
                    emissiveIntensity: 1.0,  // Muy brillante para test
                    transparent: true,
                    opacity: 0.9
                });
                enemy = new THREE.Mesh(geo, mat);
                enemy.userData.fallback = true;  // Marca para animación extra
                console.log(`Usando fallback para ${type.name}`);
            } else {
                enemy = modelTemplate.clone();
            }

            enemy.scale.set(type.scale, type.scale, type.scale);

            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            // Reducir altura para que estén al nivel del jugador
            const height = CHARACTER_HEIGHT; // 0.5, igual que el jugador
            // Spawn más cerca para test: radio * 1.2
            const spawnRadius = currentPlanetRadius * 1.2 + height;
            const pos = new THREE.Vector3(
                spawnRadius * Math.sin(phi) * Math.cos(theta),
                spawnRadius * Math.sin(phi) * Math.sin(theta),
                spawnRadius * Math.cos(phi)
            );

            enemy.position.copy(pos);
            const radial = pos.clone().normalize();
            const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), radial);
            enemy.quaternion.copy(quat);
            enemy.userData = { 
                radial: radial.clone(), 
                speed: type.speed * 2,  // DUPLICA velocidad para test
                behavior: type.behavior,
                type: type.name,
                height: height, // Usar la altura baja
                isEnemy: true,
                rotationSpeed: Math.random() * 0.5 + 0.5
            };
            
            // Asegura visibilidad: glow y sombras
            enemy.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    if (child.material) {
                        child.material.emissiveIntensity = 0.8;  // Aumenta glow
                    }
                }
            });

            scene.add(enemy);
            enemies.push(enemy);

            // Agregar trail naranja para visibilidad
            const trailPoints = [enemy.position.clone()];
            for (let j = 1; j < 5; j++) {
                const backPos = enemy.position.clone().sub(radial.clone().multiplyScalar(j * 1));
                trailPoints.push(backPos);
            }
            const trailGeometry = new THREE.BufferGeometry().setFromPoints(trailPoints);
            const trailMaterial = new THREE.LineBasicMaterial({ color: 0xff4500, transparent: true, opacity: 0.6 });
            const trail = new THREE.Line(trailGeometry, trailMaterial);
            scene.add(trail);
            enemy.userData.trail = trail;

            console.log(`Enemigo ${type.name} spawn en posición:`, pos);
        }

        function loadPersonaje(url, scale = 1.0) {
            const loader = new THREE.FBXLoader();
            loader.load(url, function(fbx) {
                personaje = fbx;
                personaje.scale.set(scale, scale, scale);
                const initialPos = new THREE.Vector3(0, originalPlanetRadius + CHARACTER_HEIGHT, 0);
                personaje.position.copy(initialPos);
                
                const initialRadial = initialPos.clone().normalize();
                const quatUp = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), initialRadial);
                const initialYaw = 0;
                const quatYaw = new THREE.Quaternion().setFromAxisAngle(initialRadial, initialYaw);
                const quat = quatUp.clone();
                quat.premultiply(quatYaw);
                personaje.quaternion.copy(quat);
                
                previousRadial = initialRadial.clone();
                
                personaje.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        if (child.material) {
                            child.material.metalness = 0.3;
                            child.material.roughness = 0.4; // Más brillante
                        }
                    }
                });
                
                scene.add(personaje);

                // Cube con mejor material
                const radius = originalPlanetRadius + CHARACTER_HEIGHT;
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(personaje.quaternion);
                forward.projectOnPlane(initialRadial).normalize();
                const distance = 20;
                const cubePos = initialRadial.clone().add(forward.clone().multiplyScalar(distance)).normalize().multiplyScalar(radius);
                const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
                const cubeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x00ff00,
                    emissive: 0x00aa00,
                    emissiveIntensity: 0.2
                });
                mixer = new THREE.AnimationMixer(personaje);

                // Cargar animaciones
                loadAnimation('models/still.fbx', 'Idle');
                loadAnimation('models/run.fbx', 'Walk');

                console.log('✅ Personaje cargado correctamente.');
                modelLoaded(); // Incrementar por el modelo del personaje
            }, undefined, function(error) {
                console.error('❌ Error al cargar el modelo:', error);
                modelLoaded(); // Incrementar incluso en error
            });
        }

        function loadAnimation(file, name) {
            const animLoader = new THREE.FBXLoader();
            animLoader.load(file, function(animFbx) {
                const clip = animFbx.animations[0]; // Asumir primer clip
                if (clip) {
                    actions[name] = mixer.clipAction(clip);
                    if (name === 'Idle') {
                        actions[name].setLoop(THREE.LoopRepeat, Infinity);
                        setActiveAction(actions[name]);
                    } else if (name === 'Walk') {
                        actions[name].setLoop(THREE.LoopRepeat, Infinity);
                    }
                    console.log(`${name} animation loaded`);
                }
                modelLoaded(); // Incrementar por cada animación
            }, undefined, function(error) {
                console.error(`Error loading ${name} animation:`, error);
                modelLoaded(); // Incrementar incluso en error
            });
        }

        function setActiveAction(actionToActivate) {
            if (activeAction === actionToActivate) return;
            if (activeAction) activeAction.fadeOut(0.3);
            
            actionToActivate.reset().setEffectiveTimeScale(1).setEffectiveWeight(1).fadeIn(0.3).play();
            activeAction = actionToActivate;
        }

        function updateAspectRatio() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        }

        function updateUI() {
            if (!gameRunning) return;
            document.getElementById('time').textContent = Math.floor(gameTime);
            document.getElementById('score').textContent = Math.floor(score);
            document.getElementById('hits').textContent = hits;
            document.getElementById('healthFill').style.width = ((MAX_HITS - hits) / MAX_HITS * 100) + '%';
            document.getElementById('planetRadius').textContent = Math.floor(currentPlanetRadius);

            // Indicadores informativos
            const invulnEl = document.getElementById('invulnIndicator');
            const lavaEl = document.getElementById('lavaWarning');
            const cooldownEl = document.getElementById('shrinkCooldown');
            if (invulnerable) {
                invulnEl.style.display = 'block';
            } else {
                invulnEl.style.display = 'none';
            }
            if (inLava) {
                lavaEl.style.display = 'block';
            } else {
                lavaEl.style.display = 'none';
            }
            if (gameTime - lastShrinkTime < SHRINK_COOLDOWN) {
                cooldownEl.style.display = 'block';
            } else {
                cooldownEl.style.display = 'none';
            }
        }

        function attemptShrinkPlanet() {
            const timeSinceLastShrink = gameTime - lastShrinkTime;
            if (timeSinceLastShrink < SHRINK_COOLDOWN) {
                return; // No encoger si en cooldown
            }
            shrinkPlanet();
            lastShrinkTime = gameTime;
        }

        function shrinkPlanet() {
            if (currentPlanetRadius <= WIN_RADIUS) return;
            const oldRadius = currentPlanetRadius;
            currentPlanetRadius = Math.max(WIN_RADIUS, currentPlanetRadius - SHRINK_AMOUNT);
            const scaleFactor = currentPlanetRadius / oldRadius;

            // Scale planet mesh (sin ajuste de repeat para que la textura se encoge con el planeta)
            if (planeta) {
                planeta.scale.multiplyScalar(scaleFactor);
            }

            // Update static obstacles positions
            for (let obj of staticObstacles) {
                if (obj.userData) {
                    let newPos;
                    if (obj.userData.isTree) {
                        // Para árboles: nueva posición = radial * (currentRadius + offset)
                        newPos = obj.userData.radial.clone().multiplyScalar(currentPlanetRadius + obj.userData.offset);
                    } else if (obj.userData.originalPosition) {
                        // Para rocas: escalar posición original
                        newPos = obj.userData.originalPosition.clone().multiplyScalar(currentPlanetRadius / originalPlanetRadius);
                    } else {
                        continue;
                    }
                    obj.position.copy(newPos);
                }
            }

            // Update lava spots positions y animar humo
            for (let lava of lavaSpots) {
                if (lava.userData && lava.userData.originalPosition) {
                    const newPos = lava.userData.originalPosition.clone().multiplyScalar(currentPlanetRadius / originalPlanetRadius);
                    lava.position.copy(newPos);
                    if (lava.userData.smoke) {
                        lava.userData.smoke.position.copy(newPos);
                        lava.userData.smoke.position.add(new THREE.Vector3(0, 1.0 + 0.5, 0)); // Ajustar altura
                    }
                }
            }

            // Update powerups positions
            for (let pu of powerUps) {
                if (pu.userData && pu.userData.originalPosition) {
                    pu.position.copy(pu.userData.originalPosition.clone().multiplyScalar(currentPlanetRadius / originalPlanetRadius));
                }
            }

            // Update enemies positions (escalar hacia el centro, ajustando height)
            for (let enemy of enemies) {
                const scaledPos = enemy.position.clone().multiplyScalar(scaleFactor);
                const adjustedPos = scaledPos.normalize().multiplyScalar(currentPlanetRadius + enemy.userData.height);
                enemy.position.copy(adjustedPos);
                enemy.userData.radial = adjustedPos.clone().normalize();
            }

            // Ajustar polvo atmosférico
            if (window.dust) {
                const positions = window.dust.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    const len = Math.sqrt(positions[i]**2 + positions[i+1]**2 + positions[i+2]**2);
                    const dir = new THREE.Vector3(positions[i], positions[i+1], positions[i+2]).normalize();
                    positions[i] = dir.x * currentPlanetRadius * (1 + (len - originalPlanetRadius) / originalPlanetRadius * 0.1);
                    positions[i+1] = dir.y * currentPlanetRadius * (1 + (len - originalPlanetRadius) / originalPlanetRadius * 0.1);
                    positions[i+2] = dir.z * currentPlanetRadius * (1 + (len - originalPlanetRadius) / originalPlanetRadius * 0.1);
                }
                window.dust.geometry.attributes.position.needsUpdate = true;
            }

            if (currentPlanetRadius <= WIN_RADIUS) {
                winGame();
            }
        }

        function winGame() {
            gameRunning = false;
            document.getElementById('winTime').textContent = Math.floor(gameTime);
            document.getElementById('winScore').textContent = Math.floor(score);
            if (score > bestScore) {
                bestScore = score;
                localStorage.setItem('bestScore', bestScore);
            }
            document.getElementById('winScreen').style.display = 'block';
        }

        function endGame() {
            gameRunning = false;
            document.getElementById('finalTime').textContent = Math.floor(gameTime);
            document.getElementById('finalScore').textContent = Math.floor(score);
            if (score > bestScore) {
                bestScore = score;
                localStorage.setItem('bestScore', bestScore);
            }
            document.getElementById('bestScore').textContent = Math.floor(bestScore);
            document.getElementById('gameOver').style.display = 'block';
        }

        // --- SPAWN DE METEORITOS CON TRAIL MEJORADO ---
        function spawnMeteor() {
            if (!isInitialized || !gameRunning || Math.random() > METEOR_SPAWN_RATE) return;

            const spawnRadius = currentPlanetRadius * 5; // Aumentado para spawns más lejanos, pero speed compensa
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const x = spawnRadius * Math.sin(phi) * Math.cos(theta);
            const y = spawnRadius * Math.sin(phi) * Math.sin(theta);
            const z = spawnRadius * Math.cos(phi);

            const meteorGeometry = new THREE.DodecahedronGeometry(METEOR_RADIUS, 1); // Mejor forma
            const meteorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                emissive: 0xFF4500,
                emissiveIntensity: 0.5 // Más glow
            });
            const meteor = new THREE.Mesh(meteorGeometry, meteorMaterial);
            meteor.castShadow = true;
            meteor.receiveShadow = true;

            meteor.position.set(x, y, z);
            const direction = new THREE.Vector3().subVectors(new THREE.Vector3(0,0,0), meteor.position).normalize();
            meteor.userData = { direction: direction, speed: METEOR_SPEED, isMeteor: true };

            // Trail mejorado con múltiples segmentos
            const trailPoints = [];
            for (let j = 0; j < 10; j++) {
                trailPoints.push(meteor.position.clone().add(direction.clone().multiplyScalar(-j * 2)));
            }
            const trailGeometry = new THREE.BufferGeometry().setFromPoints(trailPoints);
            const trailMaterial = new THREE.LineBasicMaterial({ 
                color: 0xFF4500, 
                transparent: true, 
                opacity: 0.7,
                linewidth: 2
            });
            const trail = new THREE.Line(trailGeometry, trailMaterial);
            meteor.userData.trail = trail;
            scene.add(trail);

            scene.add(meteor);
            obstacles.push(meteor);
        }

        // --- SPAWN DE POWER-UPS MEJORADO ---
        function spawnPowerUp() {
            if (!isInitialized || !gameRunning || Math.random() > POWERUP_SPAWN_RATE) return;

            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const pos = new THREE.Vector3(
                currentPlanetRadius * Math.sin(phi) * Math.cos(theta),
                currentPlanetRadius * Math.sin(phi) * Math.sin(theta),
                currentPlanetRadius * Math.cos(phi)
            );

            const powerUpGeometry = new THREE.OctahedronGeometry(POWERUP_RADIUS, 0);
            const powerUpMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x00ffff,
                emissive: 0x00ffff,
                emissiveIntensity: 0.8,
                roughness: 0.2 // Más brillante
            });
            const powerUp = new THREE.Mesh(powerUpGeometry, powerUpMaterial);
            powerUp.position.copy(pos);
            powerUp.userData.originalPosition = pos.clone().multiplyScalar(originalPlanetRadius / currentPlanetRadius);
            const radial = pos.clone().normalize();
            const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), radial);
            powerUp.quaternion.copy(quat);
            powerUp.userData = { ...powerUp.userData, isPowerUp: true };
            scene.add(powerUp);
            powerUps.push(powerUp);
        }

        function updateObstacles(deltaTime) {
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                if (obs.userData.isMeteor) {
                    // Actualizar trail mejorado
                    if (obs.userData.trail) {
                        const points = obs.userData.trail.geometry.attributes.position.array;
                        const dir = obs.userData.direction;
                        for (let j = 0; j < points.length; j += 3) {
                            const dist = j / 3 * 2;
                            points[j] = obs.position.x - dir.x * dist;
                            points[j+1] = obs.position.y - dir.y * dist;
                            points[j+2] = obs.position.z - dir.z * dist;
                        }
                        obs.userData.trail.geometry.attributes.position.needsUpdate = true;
                    }

                    obs.position.add(obs.userData.direction.clone().multiplyScalar(obs.userData.speed * deltaTime));
                    
                    if (obs.position.length() <= currentPlanetRadius + METEOR_RADIUS) {
                        const impactPos = obs.position.clone().normalize().multiplyScalar(currentPlanetRadius);
                        createExplosion(impactPos);
                        spawnLava(impactPos);
                        if (obs.userData.trail) scene.remove(obs.userData.trail);
                        scene.remove(obs);
                        obstacles.splice(i, 1);
                        continue;
                    }
                }
            }

            // Actualizar power-ups (rotación y pulso)
            for (let pu of powerUps) {
                pu.rotation.y += deltaTime * 2;
                pu.scale.setScalar(1 + Math.sin(clock.getElapsedTime() * 3) * 0.2);
            }

            // Animar humo de lava
            for (let lava of lavaSpots) {
                if (lava.userData.smoke) {
                    lava.userData.smoke.position.y += Math.sin(clock.getElapsedTime() * 2 + lava.position.x) * 0.01;
                    lava.userData.smoke.rotation.y += deltaTime * 0.5;
                }
            }

            // Actualizar enemigos variados
            if (personaje) {
                const playerPos = personaje.position.clone();
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    const enemyPos = enemy.position.clone();
                    const radial = enemyPos.clone().normalize();

                    let direction;
                    if (enemy.userData.behavior === 'chase' || enemy.userData.behavior === 'jump') {
                        direction = playerPos.clone().sub(enemyPos).normalize();
                        direction.projectOnPlane(radial);
                        if (direction.length() < 0.01) {
                            direction = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
                            direction.projectOnPlane(radial);
                        }
                        direction.normalize();
                    }

                    // Para jumper, agregar salto ocasional en dirección radial
                    let jumpOffset = new THREE.Vector3(0, 0, 0);
                    if (enemy.userData.behavior === 'jump' && Math.random() < 0.02) {
                        jumpOffset = radial.clone().multiplyScalar(3.0); // Salto radial más visible
                    }

                    const moveVec = direction.clone().multiplyScalar(enemy.userData.speed * deltaTime);
                    const newPos = enemyPos.clone().add(moveVec).add(jumpOffset).normalize().multiplyScalar(currentPlanetRadius + enemy.userData.height);

                    enemy.position.copy(newPos);
                    const newRadial = newPos.clone().normalize();
                    if (!enemy.userData.radial.equals(newRadial)) {
                        const correction = new THREE.Quaternion().setFromUnitVectors(enemy.userData.radial, newRadial);
                        enemy.quaternion.premultiply(correction);
                        enemy.userData.radial.copy(newRadial);
                    }

                    // Rotación para variedad
                    enemy.rotation.y += deltaTime * (1 + Math.random());

                    // Animación extra para fallback o todos
                    if (enemy.userData.fallback || true) {
                        enemy.rotation.x += deltaTime * enemy.userData.rotationSpeed * 0.5;
                        enemy.rotation.z += Math.sin(gameTime * 2 + i) * deltaTime * 0.2;  // Bobbing para "vida"
                        // Actualiza trail si existe
                        if (enemy.userData.trail) {
                            const points = enemy.userData.trail.geometry.attributes.position.array;
                            points[0] = enemy.position.x; points[1] = enemy.position.y; points[2] = enemy.position.z;
                            for (let j = 1; j < points.length / 3; j++) {
                                const dist = j * 1;
                                points[j*3] = enemy.position.x - radial.x * dist;
                                points[j*3+1] = enemy.position.y - radial.y * dist;
                                points[j*3+2] = enemy.position.z - radial.z * dist;
                            }
                            enemy.userData.trail.geometry.attributes.position.needsUpdate = true;
                        }
                    }
                }
            }
        }

        function createExplosion(position) {
            const explosionGeometry = new THREE.SphereGeometry(EXPLOSION_RADIUS, 32, 32);
            const explosionMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFF4500, 
                transparent: true, 
                opacity: 0.9 
            });
            const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);

            explosion.position.copy(position);
            explosion.userData = { 
                startTime: clock.getElapsedTime(), 
                duration: EXPLOSION_DURATION, 
                isExplosion: true 
            };

            scene.add(explosion);
            explosions.push(explosion);

            // Partículas de explosión para belleza
            for (let k = 0; k < 20; k++) {
                const particleGeo = new THREE.SphereGeometry(0.1, 4, 4);
                const particleMat = new THREE.MeshBasicMaterial({
                    color: 0xFF6600,
                    transparent: true,
                    opacity: 1
                });
                const particle = new THREE.Mesh(particleGeo, particleMat);
                particle.position.copy(position);
                const dir = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
                particle.userData = { velocity: dir.multiplyScalar(10), life: 1.0 };
                scene.add(particle);
                explosions.push(particle);
            }
        }

        // --- DETECCIÓN DE COLISIONES ESTÁTICAS ---
        function checkStaticCollisions(newPos) {
            for (let staticObj of staticObstacles) {
                let collisionDist = STATIC_COLLISION_DISTANCE;
                if (staticObj.userData && staticObj.userData.isTree) {
                    collisionDist = TREE_COLLISION_DISTANCE;
                }
                const dist = newPos.distanceTo(staticObj.position);
                if (dist < collisionDist) {
                    return true;
                }
            }
            return false;
        }

        function checkCollisions(deltaTime) {
            if (!personaje || !gameRunning || !isInitialized) return;

            const characterPos = personaje.position;

            // Colisión con meteoritos
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                if (obs.userData.isMeteor) {
                    const dist = characterPos.distanceTo(obs.position);
                    if (dist < COLLISION_DISTANCE && !invulnerable) {
                        takeHit();
                        createExplosion(obs.position);
                        if (obs.userData.trail) scene.remove(obs.userData.trail);
                        scene.remove(obs);
                        obstacles.splice(i, 1);
                    }
                }
            }

            // Colisión con explosiones
            for (let i = explosions.length - 1; i >= 0; i--) {
                const exp = explosions[i];
                if (exp.userData.isExplosion && exp.geometry.parameters.radius === EXPLOSION_RADIUS) {
                    const dist = characterPos.distanceTo(exp.position);
                    if (dist < BLAST_DAMAGE_RADIUS && !invulnerable) {
                        takeHit();
                    }
                }
            }

            // Colisión con power-ups (distancia aumentada)
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const pu = powerUps[i];
                const dist = characterPos.distanceTo(pu.position);
                if (dist < COLLISION_DISTANCE + 0.5) { // Más fácil de recoger
                    heal();
                    score += SCORE_PER_POWERUP;
                    scene.remove(pu);
                    powerUps.splice(i, 1);
                }
            }

            // Colisión con enemigos
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const dist = characterPos.distanceTo(enemy.position);
                if (dist < COLLISION_DISTANCE && !invulnerable) {
                    takeHit();
                    score += SCORE_PER_ENEMY; // Puntos por destruir enemigo
                    if (enemy.userData.trail) scene.remove(enemy.userData.trail);
                    scene.remove(enemy);
                    enemies.splice(i, 1);
                }
            }

            // Daño de lava mejorado (distancia aumentada a 1.5 para cubrir mejor)
            if (!lavaSpots || lavaSpots.length === 0) return;
            let inLavaNow = false;
            for (let lava of lavaSpots) {
                if (lava && lava.position && characterPos.distanceTo(lava.position) < 1.5) {
                    inLavaNow = true;
                    break;
                }
            }
            if (inLavaNow && !inLava) {
                lavaDamageTimer = 0;
            }
            inLava = inLavaNow;
            if (inLava && !invulnerable) {
                lavaDamageTimer += deltaTime;
                if (lavaDamageTimer >= LAVA_DAMAGE_INTERVAL) {
                    takeHit();
                    lavaDamageTimer = 0;
                }
            }
        }

        function takeHit() {
            if (!gameRunning) return;
            hits++;
            document.getElementById('hits').textContent = hits;
            invulnerable = true;
            invulnTimer = INVULN_DURATION;
            if (hits >= MAX_HITS) {
                endGame();
            }
        }

        function heal() {
            if (hits > 0) {
                hits--;
                document.getElementById('hits').textContent = hits;
            }
        }

        function update() {
            const deltaTime = clock.getDelta();
            if (gameRunning && isInitialized) {
                gameTime += deltaTime;
                score += SCORE_PER_SECOND * deltaTime;

                const currentSecond = Math.floor(gameTime);
                if (currentSecond > lastSecond) {
                    METEOR_SPAWN_RATE = Math.min(0.05, METEOR_SPAWN_RATE + 0.002); // Aumento más rápido
                    ENEMY_SPAWN_RATE = Math.min(0.01, ENEMY_SPAWN_RATE + 0.0005); // Aumento para enemigos
                    lastSecond = currentSecond;
                }

                const currentInterval = Math.floor(gameTime / DIFFICULTY_INCREASE_INTERVAL);
                if (currentInterval > lastDifficultyIncrease) {
                    POWERUP_SPAWN_RATE = Math.min(0.005, POWERUP_SPAWN_RATE + 0.0002);
                    lastDifficultyIncrease = currentInterval;
                }

                if (invulnerable) {
                    invulnTimer -= deltaTime;
                    if (invulnTimer <= 0) {
                        invulnerable = false;
                    }
                }

                spawnMeteor();
                spawnEnemy(); // Nuevo: spawn de enemigos
                spawnPowerUp();
                updateObstacles(deltaTime);
                checkCollisions(deltaTime);
            }

            if (mixer) mixer.update(deltaTime);
            if (personaje && gameRunning) {
                personaje.visible = !invulnerable || (Math.floor(clock.getElapsedTime() * 10) % 2 === 0);
                updateCharacter(deltaTime);
                if (personaje) {
                    const adjustedPos = personaje.position.clone().normalize().multiplyScalar(currentPlanetRadius + CHARACTER_HEIGHT);
                    personaje.position.copy(adjustedPos);
                    const newRadial = adjustedPos.normalize();
                    if (!previousRadial.equals(newRadial)) {
                        const correction = new THREE.Quaternion().setFromUnitVectors(previousRadial, newRadial);
                        personaje.quaternion.premultiply(correction);
                        previousRadial.copy(newRadial);
                    }
                }
                updateCamera();
            }

            // Actualizar minimapa
            minimapAngle += deltaTime * 0.2;
            minimapCamera.position.x = Math.sin(minimapAngle) * currentPlanetRadius * 3; // Usar currentRadius
            minimapCamera.position.z = Math.cos(minimapAngle) * currentPlanetRadius * 3;
            minimapCamera.lookAt(0, 0, 0);

            // Actualizar explosiones y partículas
            for (let i = explosions.length - 1; i >= 0; i--) {
                const exp = explosions[i];
                if (exp.userData.isExplosion) {
                    if (exp.geometry.parameters.radius === EXPLOSION_RADIUS) {
                        const elapsed = clock.getElapsedTime() - exp.userData.startTime;
                        const progress = elapsed / exp.userData.duration;
                        if (progress >= 1) {
                            scene.remove(exp);
                            explosions.splice(i, 1);
                        } else {
                            exp.scale.setScalar(1 + progress * 3);
                            exp.material.opacity = Math.max(0, 0.9 * (1 - progress));
                            if (progress > 0.5) {
                                exp.material.color.setHSL(0, 1, (1 - progress) * 0.5);
                            }
                        }
                    } else {
                        // Partículas
                        exp.userData.life -= deltaTime;
                        if (exp.userData.life <= 0) {
                            scene.remove(exp);
                            explosions.splice(i, 1);
                        } else {
                            exp.position.add(exp.userData.velocity.clone().multiplyScalar(deltaTime));
                            exp.material.opacity = exp.userData.life;
                            exp.scale.setScalar(1 - exp.userData.life);
                        }
                    }
                }
            }
        }

        function updateCharacter(deltaTime) {
            if (!personaje) return;
            const currentRadial = personaje.position.clone().normalize();
            const isMoving = keysPressed['w'] || keysPressed['arrowup'];

            if (keysPressed['a'] || keysPressed['arrowleft']) {
                const angle = -TURN_SPEED * deltaTime;
                const rotation = new THREE.Quaternion().setFromAxisAngle(currentRadial, angle);
                personaje.quaternion.premultiply(rotation);
            }
            if (keysPressed['d'] || keysPressed['arrowright']) {
                const angle = TURN_SPEED * deltaTime;
                const rotation = new THREE.Quaternion().setFromAxisAngle(currentRadial, angle);
                personaje.quaternion.premultiply(rotation);
            }

            if (keysPressed['s'] || keysPressed['arrowdown']) {
                const angle = Math.PI * deltaTime * 2;
                const rotation = new THREE.Quaternion().setFromAxisAngle(currentRadial, angle);
                personaje.quaternion.premultiply(rotation);
            }

            const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(personaje.quaternion);
            forward.projectOnPlane(currentRadial).normalize();

            if (isMoving) {
                const radius = currentPlanetRadius + CHARACTER_HEIGHT;
                const moveVector = forward.clone().multiplyScalar(FORWARD_SPEED * deltaTime);
                const oldPos = personaje.position.clone();
                const tentativeNewPos = oldPos.clone().add(moveVector).normalize().multiplyScalar(radius);
                
                if (!checkStaticCollisions(tentativeNewPos)) {
                    const oldRadial = previousRadial.clone();
                    personaje.position.copy(tentativeNewPos);
                    const newRadial = tentativeNewPos.clone().normalize();

                    if (actions['Walk']) setActiveAction(actions['Walk']);

                    if (!oldRadial.equals(newRadial)) {
                        const correction = new THREE.Quaternion().setFromUnitVectors(oldRadial, newRadial);
                        personaje.quaternion.premultiply(correction);
                    }

                    previousRadial.copy(newRadial);
                } else {
                    if (actions['Idle']) setActiveAction(actions['Idle']);
                }
            } else {
                if (actions['Idle']) setActiveAction(actions['Idle']);
            }
        }

        function updateCamera() {
            if (!personaje) return;
            const characterUp = personaje.position.clone().normalize();
            const cameraOffset = new THREE.Vector3(0, CAMERA_HEIGHT, -CAMERA_DISTANCE * 0.4); 
            cameraOffset.applyMatrix4(personaje.matrixWorld);

            const lookAtTarget = new THREE.Vector3().setFromMatrixPosition(personaje.matrixWorld);
            lookAtTarget.add(characterUp.multiplyScalar(4));
            
            camera.position.lerp(cameraOffset, 0.05);
            camera.up.copy(characterUp);
            camera.lookAt(lookAtTarget);
        }

        function render() {
            requestAnimationFrame(render);
            update();
            renderer.render(scene, camera);
            minimapRenderer.render(scene, minimapCamera);
        }
    </script>
</body>
</html>