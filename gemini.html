<!DOCTYPE html>
<html>
<head>
    <title>Personaje en Planeta con Three.js</title>
    <style>
        body { margin: 0; }
        #container { width: 100%; height: 100%; }
    </style>
</head>
<body>
    <div id="container"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // --- REFERENCIAS GLOBALES ---
        var renderer, scene, camera, planeta, personaje, previousRadial;
        var clock = new THREE.Clock();

        // --- GESTIÓN DE ANIMACIÓN ---
        var mixer;
        const actions = {}; 
        let activeAction; 

        // --- CONSTANTES DE CONFIGURACIÓN ---
        const PLANET_RADIUS = 5;
        const CHARACTER_HEIGHT = 0.15; // Ajustado para que toque el suelo (mitad de la altura escalada aproximada)
        const CHARACTER_SCALE = 0.3;
        const FORWARD_SPEED = 3.0; // Velocidad constante hacia adelante
        const TURN_SPEED = 2.0; // Velocidad de giro (para A/D y flechas izquierda/derecha)
        // --- CONSTANTES DE CÁMARA AJUSTADAS PARA VISTA MÁS LEJANA Y ELEVADA ---
        const CAMERA_DISTANCE = 25; // Aumentado más para ver más del planeta
        const CAMERA_HEIGHT = 18;   // Aumentado proporcionalmente para mantener ángulo elevado

        // --- ESTADO DEL TECLADO ---
        var keysPressed = {};
        document.addEventListener('keydown', (event) => keysPressed[event.key.toLowerCase()] = true, false);
        document.addEventListener('keyup', (event) => keysPressed[event.key.toLowerCase()] = false, false);

        init();
        loadPlaneta(PLANET_RADIUS, 'https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg');
        loadPersonajeGLB('https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb', CHARACTER_SCALE);
        render();

        function init() {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(new THREE.Color(0x111122));
            document.getElementById('container').appendChild(renderer.domElement);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // Posición inicial de cámara más lejana y elevada para apreciar el planeta completo
            camera.position.set(0, PLANET_RADIUS + CAMERA_HEIGHT + 5, 15);
            camera.lookAt(0, PLANET_RADIUS, 0);
            
            scene.add(new THREE.AmbientLight(0x666666));
            const luz = new THREE.DirectionalLight(0xffffff, 1);
            luz.position.set(10, 10, 10);
            scene.add(luz);

            window.addEventListener('resize', updateAspectRatio);
        }

        function loadPlaneta(radio, texturaURL) {
            const geometria = new THREE.SphereGeometry(radio, 64, 64);
            const textura = new THREE.TextureLoader().load(texturaURL);
            const material = new THREE.MeshStandardMaterial({ map: textura });
            planeta = new THREE.Mesh(geometria, material);
            scene.add(planeta);
        }

        function loadPersonajeGLB(url, scale = 1.0) {
            const loader = new THREE.GLTFLoader();
            loader.load(url, function(gltf) {
                personaje = gltf.scene;
                personaje.scale.set(scale, scale, scale);
                personaje.position.set(0, PLANET_RADIUS + CHARACTER_HEIGHT, 0);
                
                // Orientación inicial: alinear up con radial, yaw=0 (mirando hacia -Z)
                const initialRadial = personaje.position.clone().normalize();
                const quatUp = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), initialRadial);
                const initialYaw = 0; // Ajusta a Math.PI si quieres que mire en dirección opuesta
                const quatYaw = new THREE.Quaternion().setFromAxisAngle(initialRadial, initialYaw);
                personaje.quaternion.copy(quatYaw.premultiply(quatUp));
                
                previousRadial = initialRadial.clone();
                
                scene.add(personaje);

                mixer = new THREE.AnimationMixer(personaje);
                const animationClips = gltf.animations;
                
                // Buscar clips por nombre (insensible a mayúsculas)
                for (let clip of animationClips) {
                    const name = clip.name.toLowerCase();
                    if (name.includes('idle')) {
                        actions['Idle'] = mixer.clipAction(clip);
                    }
                    if (name.includes('walk') || name.includes('running')) {
                        actions['Walk'] = mixer.clipAction(clip);
                    }
                }
                
                console.log('Animaciones encontradas:', Object.keys(actions));
                if (actions['Walk']) setActiveAction(actions['Walk']); // Inicia con walk ya que se mueve siempre

                console.log('✅ Personaje cargado correctamente.');
            }, undefined, function(error) {
                console.error('❌ Error al cargar el modelo:', error);
            });
        }

        function setActiveAction(actionToActivate) {
            if (activeAction === actionToActivate) return;
            if (activeAction) activeAction.fadeOut(0.3);
            
            actionToActivate.reset().setEffectiveTimeScale(1).setEffectiveWeight(1).fadeIn(0.3).play();
            activeAction = actionToActivate;
        }

        function updateAspectRatio() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        }

        function update() {
            const deltaTime = clock.getDelta();
            if (mixer) mixer.update(deltaTime);
            if (personaje) {
                updateCharacter(deltaTime);
                updateCamera();
            }
        }

        // --- CONTROLADOR DE PERSONAJE: MOVIMIENTO CONSTANTE ADELANTE + GIRO CON TECLAS ---
        function updateCharacter(deltaTime) {
            const currentRadial = personaje.position.clone().normalize();

            // Dirección forward local transformada a world ( +Z para adelante correcto)
            const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(personaje.quaternion);
            forward.projectOnPlane(currentRadial).normalize();

            // Movimiento constante hacia adelante
            const moveVector = forward.clone().multiplyScalar(FORWARD_SPEED * deltaTime);
            personaje.position.add(moveVector);

            // Giro con A/D o flechas izquierda/derecha (cambiar dirección)
            const isTurning = keysPressed['a'] || keysPressed['d'] || keysPressed['arrowleft'] || keysPressed['arrowright'];
            if (isTurning && actions['Walk']) setActiveAction(actions['Walk']); // Mantén walk si gira
            else if (actions['Idle']) setActiveAction(actions['Idle']); // Idle si no (pero como siempre se mueve, raro)

            if (keysPressed['a'] || keysPressed['arrowleft']) {
                const angle = -TURN_SPEED * deltaTime; // Izquierda
                const rotation = new THREE.Quaternion().setFromAxisAngle(currentRadial, angle);
                personaje.quaternion.premultiply(rotation);
            }
            if (keysPressed['d'] || keysPressed['arrowright']) {
                const angle = TURN_SPEED * deltaTime; // Derecha
                const rotation = new THREE.Quaternion().setFromAxisAngle(currentRadial, angle);
                personaje.quaternion.premultiply(rotation);
            }

            // Opcional: S o flecha abajo para frenar o revertir dirección temporalmente
            if (keysPressed['s'] || keysPressed['arrowdown']) {
                // Revertir dirección temporalmente (gira 180° rápido o reduce speed)
                const angle = Math.PI * deltaTime * 2; // Giro rápido de 180° en ~0.5s
                const rotation = new THREE.Quaternion().setFromAxisAngle(currentRadial, angle);
                personaje.quaternion.premultiply(rotation);
            }

            // Proyectar de vuelta a la esfera
            const oldRadial = previousRadial.clone();
            personaje.position.normalize().multiplyScalar(PLANET_RADIUS + CHARACTER_HEIGHT);
            const newRadial = personaje.position.clone().normalize();

            // Corrección para alinear el nuevo up
            if (!oldRadial.equals(newRadial)) {
                const correction = new THREE.Quaternion().setFromUnitVectors(oldRadial, newRadial);
                personaje.quaternion.premultiply(correction);
            }

            // Actualizar previousRadial
            previousRadial.copy(newRadial);
        }

        function updateCamera() {
            const characterUp = personaje.position.clone().normalize();
            // Offset ajustado: más alto y con distancia atrás reducida para ángulo más elevado desde lejos
            const cameraOffset = new THREE.Vector3(0, CAMERA_HEIGHT, -CAMERA_DISTANCE * 0.6); 
            cameraOffset.applyMatrix4(personaje.matrixWorld);

            const lookAtTarget = new THREE.Vector3().setFromMatrixPosition(personaje.matrixWorld);
            lookAtTarget.add(characterUp.multiplyScalar(2.5)); // Ajustado para mirar más alto desde la distancia
            
            camera.position.lerp(cameraOffset, 0.05); // Lerp más lento para seguimiento suave
            camera.up.copy(characterUp);
            camera.lookAt(lookAtTarget);
        }

        function render() {
            requestAnimationFrame(render);
            update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>